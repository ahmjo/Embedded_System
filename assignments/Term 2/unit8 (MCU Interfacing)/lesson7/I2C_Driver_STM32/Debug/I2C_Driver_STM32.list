
I2C_Driver_STM32.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000130  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000117c  08000130  08000130  00001130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000020  080012ac  080012ac  000022ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080012cc  080012cc  000022d4  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  080012cc  080012cc  000022d4  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  080012cc  080012d4  000022d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080012cc  080012cc  000022cc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  080012d0  080012d0  000022d0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000000  20000000  20000000  000022d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000000b4  20000000  080012d4  00003000  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  200000b4  080012d4  000030b4  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  000022d4  2**0
                  CONTENTS, READONLY
 12 .debug_info   00002a69  00000000  00000000  000022fd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00000bbc  00000000  00000000  00004d66  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    000012e6  00000000  00000000  00005922  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 000002e0  00000000  00000000  00006c08  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00000258  00000000  00000000  00006ee8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  000039a6  00000000  00000000  00007140  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0000494b  00000000  00000000  0000aae6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    0000ca84  00000000  00000000  0000f431  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  0001beb5  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0000098c  00000000  00000000  0001bef8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000130 <__do_global_dtors_aux>:
 8000130:	b510      	push	{r4, lr}
 8000132:	4c05      	ldr	r4, [pc, #20]	@ (8000148 <__do_global_dtors_aux+0x18>)
 8000134:	7823      	ldrb	r3, [r4, #0]
 8000136:	b933      	cbnz	r3, 8000146 <__do_global_dtors_aux+0x16>
 8000138:	4b04      	ldr	r3, [pc, #16]	@ (800014c <__do_global_dtors_aux+0x1c>)
 800013a:	b113      	cbz	r3, 8000142 <__do_global_dtors_aux+0x12>
 800013c:	4804      	ldr	r0, [pc, #16]	@ (8000150 <__do_global_dtors_aux+0x20>)
 800013e:	f3af 8000 	nop.w
 8000142:	2301      	movs	r3, #1
 8000144:	7023      	strb	r3, [r4, #0]
 8000146:	bd10      	pop	{r4, pc}
 8000148:	20000000 	.word	0x20000000
 800014c:	00000000 	.word	0x00000000
 8000150:	08001294 	.word	0x08001294

08000154 <frame_dummy>:
 8000154:	b508      	push	{r3, lr}
 8000156:	4b03      	ldr	r3, [pc, #12]	@ (8000164 <frame_dummy+0x10>)
 8000158:	b11b      	cbz	r3, 8000162 <frame_dummy+0xe>
 800015a:	4903      	ldr	r1, [pc, #12]	@ (8000168 <frame_dummy+0x14>)
 800015c:	4803      	ldr	r0, [pc, #12]	@ (800016c <frame_dummy+0x18>)
 800015e:	f3af 8000 	nop.w
 8000162:	bd08      	pop	{r3, pc}
 8000164:	00000000 	.word	0x00000000
 8000168:	20000004 	.word	0x20000004
 800016c:	08001294 	.word	0x08001294

08000170 <eeprom_init>:
 */

#include "I2C_Slave_EEPROM.h"

void eeprom_init(void)
{
 8000170:	b580      	push	{r7, lr}
 8000172:	b08a      	sub	sp, #40	@ 0x28
 8000174:	af00      	add	r7, sp, #0
	//I2C_Init
	//PB6 : I2C1_SCL
	//PB7 : I2C_SDA
	I2C_Config_t I2C1CFG;

	I2C1CFG.General_Call_Address_Detection = I2C_ENGC_Enable;
 8000176:	2340      	movs	r3, #64	@ 0x40
 8000178:	623b      	str	r3, [r7, #32]
	I2C1CFG.I2C_ACK_Control = I2C_ACK_Enable;
 800017a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800017e:	61fb      	str	r3, [r7, #28]
	I2C1CFG.I2C_ClockSpeed = I2C_SCLK_SM_100K;
 8000180:	4b09      	ldr	r3, [pc, #36]	@ (80001a8 <eeprom_init+0x38>)
 8000182:	607b      	str	r3, [r7, #4]
	I2C1CFG.I2C_Mode = 	I2C_Mode_I2C;
 8000184:	2300      	movs	r3, #0
 8000186:	60fb      	str	r3, [r7, #12]
	I2C1CFG.P_Slave_Event_CallBack = NULL;
 8000188:	2300      	movs	r3, #0
 800018a:	627b      	str	r3, [r7, #36]	@ 0x24
	I2C1CFG.StretchMode = I2C_StretchMode_Enable;
 800018c:	2300      	movs	r3, #0
 800018e:	60bb      	str	r3, [r7, #8]
	MCAL_I2C_GPIO_Set_Pins(I2C1);
 8000190:	4806      	ldr	r0, [pc, #24]	@ (80001ac <eeprom_init+0x3c>)
 8000192:	f000 fabd 	bl	8000710 <MCAL_I2C_GPIO_Set_Pins>
	MCAL_I2C_Init(I2C1, &I2C1CFG);
 8000196:	1d3b      	adds	r3, r7, #4
 8000198:	4619      	mov	r1, r3
 800019a:	4804      	ldr	r0, [pc, #16]	@ (80001ac <eeprom_init+0x3c>)
 800019c:	f000 f9ac 	bl	80004f8 <MCAL_I2C_Init>
}
 80001a0:	bf00      	nop
 80001a2:	3728      	adds	r7, #40	@ 0x28
 80001a4:	46bd      	mov	sp, r7
 80001a6:	bd80      	pop	{r7, pc}
 80001a8:	000186a0 	.word	0x000186a0
 80001ac:	40005400 	.word	0x40005400

080001b0 <eeprom_write_Nbytes>:


unsigned char eeprom_write_Nbytes(unsigned int Memory_address, unsigned char* bytes, uint8_t Data_Length)
{
 80001b0:	b580      	push	{r7, lr}
 80001b2:	b0c8      	sub	sp, #288	@ 0x120
 80001b4:	af02      	add	r7, sp, #8
 80001b6:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 80001ba:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 80001be:	6018      	str	r0, [r3, #0]
 80001c0:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 80001c4:	f5a3 7388 	sub.w	r3, r3, #272	@ 0x110
 80001c8:	6019      	str	r1, [r3, #0]
 80001ca:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 80001ce:	f2a3 1311 	subw	r3, r3, #273	@ 0x111
 80001d2:	701a      	strb	r2, [r3, #0]
	uint8_t i = 0;
 80001d4:	2300      	movs	r3, #0
 80001d6:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
	uint8_t buffer[256];
	buffer[0] = (uint8_t) (Memory_address >> 8); //Upper memory address
 80001da:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 80001de:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 80001e2:	681b      	ldr	r3, [r3, #0]
 80001e4:	0a1b      	lsrs	r3, r3, #8
 80001e6:	b2da      	uxtb	r2, r3
 80001e8:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 80001ec:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 80001f0:	701a      	strb	r2, [r3, #0]
	buffer[1] = (uint8_t) (Memory_address);		 //Lower memory address
 80001f2:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 80001f6:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 80001fa:	681b      	ldr	r3, [r3, #0]
 80001fc:	b2da      	uxtb	r2, r3
 80001fe:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 8000202:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8000206:	705a      	strb	r2, [r3, #1]

	for(i=2 ; i < (Data_Length + 2) ; i++) buffer[i] = bytes[i-2];
 8000208:	2302      	movs	r3, #2
 800020a:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
 800020e:	e015      	b.n	800023c <eeprom_write_Nbytes+0x8c>
 8000210:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 8000214:	3b02      	subs	r3, #2
 8000216:	f507 728c 	add.w	r2, r7, #280	@ 0x118
 800021a:	f5a2 7288 	sub.w	r2, r2, #272	@ 0x110
 800021e:	6812      	ldr	r2, [r2, #0]
 8000220:	441a      	add	r2, r3
 8000222:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 8000226:	7811      	ldrb	r1, [r2, #0]
 8000228:	f507 728c 	add.w	r2, r7, #280	@ 0x118
 800022c:	f5a2 7282 	sub.w	r2, r2, #260	@ 0x104
 8000230:	54d1      	strb	r1, [r2, r3]
 8000232:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 8000236:	3301      	adds	r3, #1
 8000238:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
 800023c:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 8000240:	f2a3 1311 	subw	r3, r3, #273	@ 0x111
 8000244:	781b      	ldrb	r3, [r3, #0]
 8000246:	1c5a      	adds	r2, r3, #1
 8000248:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 800024c:	429a      	cmp	r2, r3
 800024e:	dadf      	bge.n	8000210 <eeprom_write_Nbytes+0x60>

	MCAL_I2C_Master_TX(I2C1, EEPROM_Slave_address, &buffer, (Data_Length+2), With_Stop, Start);
 8000250:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 8000254:	f2a3 1311 	subw	r3, r3, #273	@ 0x111
 8000258:	781b      	ldrb	r3, [r3, #0]
 800025a:	3302      	adds	r3, #2
 800025c:	4619      	mov	r1, r3
 800025e:	f107 0214 	add.w	r2, r7, #20
 8000262:	2300      	movs	r3, #0
 8000264:	9301      	str	r3, [sp, #4]
 8000266:	2300      	movs	r3, #0
 8000268:	9300      	str	r3, [sp, #0]
 800026a:	460b      	mov	r3, r1
 800026c:	212a      	movs	r1, #42	@ 0x2a
 800026e:	4804      	ldr	r0, [pc, #16]	@ (8000280 <eeprom_write_Nbytes+0xd0>)
 8000270:	f000 fa98 	bl	80007a4 <MCAL_I2C_Master_TX>
	return 0;
 8000274:	2300      	movs	r3, #0

}
 8000276:	4618      	mov	r0, r3
 8000278:	f507 778c 	add.w	r7, r7, #280	@ 0x118
 800027c:	46bd      	mov	sp, r7
 800027e:	bd80      	pop	{r7, pc}
 8000280:	40005400 	.word	0x40005400

08000284 <eeprom_read_byte>:


unsigned char eeprom_read_byte(unsigned int address, uint8_t* dataOut, uint8_t dataLen)
{
 8000284:	b580      	push	{r7, lr}
 8000286:	b088      	sub	sp, #32
 8000288:	af02      	add	r7, sp, #8
 800028a:	60f8      	str	r0, [r7, #12]
 800028c:	60b9      	str	r1, [r7, #8]
 800028e:	4613      	mov	r3, r2
 8000290:	71fb      	strb	r3, [r7, #7]
	uint8_t buffer[2];
	buffer[0] = (uint8_t) (address >> 8); //Upper memory address
 8000292:	68fb      	ldr	r3, [r7, #12]
 8000294:	0a1b      	lsrs	r3, r3, #8
 8000296:	b2db      	uxtb	r3, r3
 8000298:	753b      	strb	r3, [r7, #20]
	buffer[1] = (uint8_t) (address);	  //Lower memory address
 800029a:	68fb      	ldr	r3, [r7, #12]
 800029c:	b2db      	uxtb	r3, r3
 800029e:	757b      	strb	r3, [r7, #21]

	MCAL_I2C_Master_TX(I2C1, EEPROM_Slave_address, &buffer, 2, Without_Stop, Start);
 80002a0:	f107 0214 	add.w	r2, r7, #20
 80002a4:	2300      	movs	r3, #0
 80002a6:	9301      	str	r3, [sp, #4]
 80002a8:	2301      	movs	r3, #1
 80002aa:	9300      	str	r3, [sp, #0]
 80002ac:	2302      	movs	r3, #2
 80002ae:	212a      	movs	r1, #42	@ 0x2a
 80002b0:	4808      	ldr	r0, [pc, #32]	@ (80002d4 <eeprom_read_byte+0x50>)
 80002b2:	f000 fa77 	bl	80007a4 <MCAL_I2C_Master_TX>
	MCAL_I2C_Master_RX(I2C1, EEPROM_Slave_address, dataOut, dataLen, With_Stop, repeated_Start);
 80002b6:	79fb      	ldrb	r3, [r7, #7]
 80002b8:	2201      	movs	r2, #1
 80002ba:	9201      	str	r2, [sp, #4]
 80002bc:	2200      	movs	r2, #0
 80002be:	9200      	str	r2, [sp, #0]
 80002c0:	68ba      	ldr	r2, [r7, #8]
 80002c2:	212a      	movs	r1, #42	@ 0x2a
 80002c4:	4803      	ldr	r0, [pc, #12]	@ (80002d4 <eeprom_read_byte+0x50>)
 80002c6:	f000 fbaf 	bl	8000a28 <MCAL_I2C_Master_RX>
	return 0;
 80002ca:	2300      	movs	r3, #0
}
 80002cc:	4618      	mov	r0, r3
 80002ce:	3718      	adds	r7, #24
 80002d0:	46bd      	mov	sp, r7
 80002d2:	bd80      	pop	{r7, pc}
 80002d4:	40005400 	.word	0x40005400

080002d8 <EXTI0_IRQHandler>:
 * ****** ISR Functions ****************************
 * *************************************************
*/

void EXTI0_IRQHandler(void)
{
 80002d8:	b580      	push	{r7, lr}
 80002da:	af00      	add	r7, sp, #0
	//cleared by writing 1 into the bit (EXTI_PR)
	EXTI->PR |= (1<<0);
 80002dc:	4b05      	ldr	r3, [pc, #20]	@ (80002f4 <EXTI0_IRQHandler+0x1c>)
 80002de:	695b      	ldr	r3, [r3, #20]
 80002e0:	4a04      	ldr	r2, [pc, #16]	@ (80002f4 <EXTI0_IRQHandler+0x1c>)
 80002e2:	f043 0301 	orr.w	r3, r3, #1
 80002e6:	6153      	str	r3, [r2, #20]
	//Call IRQ Call
	GP_IRQ_CallBack[0]();
 80002e8:	4b03      	ldr	r3, [pc, #12]	@ (80002f8 <EXTI0_IRQHandler+0x20>)
 80002ea:	681b      	ldr	r3, [r3, #0]
 80002ec:	4798      	blx	r3
}
 80002ee:	bf00      	nop
 80002f0:	bd80      	pop	{r7, pc}
 80002f2:	bf00      	nop
 80002f4:	40010400 	.word	0x40010400
 80002f8:	2000001c 	.word	0x2000001c

080002fc <EXTI1_IRQHandler>:

void EXTI1_IRQHandler(void)
{
 80002fc:	b580      	push	{r7, lr}
 80002fe:	af00      	add	r7, sp, #0
	//cleared by writing 1 into the bit (EXTI_PR)
	EXTI->PR |= (1<<1);
 8000300:	4b05      	ldr	r3, [pc, #20]	@ (8000318 <EXTI1_IRQHandler+0x1c>)
 8000302:	695b      	ldr	r3, [r3, #20]
 8000304:	4a04      	ldr	r2, [pc, #16]	@ (8000318 <EXTI1_IRQHandler+0x1c>)
 8000306:	f043 0302 	orr.w	r3, r3, #2
 800030a:	6153      	str	r3, [r2, #20]
	//Call IRQ Call
	GP_IRQ_CallBack[1]();
 800030c:	4b03      	ldr	r3, [pc, #12]	@ (800031c <EXTI1_IRQHandler+0x20>)
 800030e:	685b      	ldr	r3, [r3, #4]
 8000310:	4798      	blx	r3
}
 8000312:	bf00      	nop
 8000314:	bd80      	pop	{r7, pc}
 8000316:	bf00      	nop
 8000318:	40010400 	.word	0x40010400
 800031c:	2000001c 	.word	0x2000001c

08000320 <EXTI2_IRQHandler>:

void EXTI2_IRQHandler(void)
{
 8000320:	b580      	push	{r7, lr}
 8000322:	af00      	add	r7, sp, #0
	//cleared by writing 1 into the bit (EXTI_PR)
	EXTI->PR |= (1<<2);
 8000324:	4b05      	ldr	r3, [pc, #20]	@ (800033c <EXTI2_IRQHandler+0x1c>)
 8000326:	695b      	ldr	r3, [r3, #20]
 8000328:	4a04      	ldr	r2, [pc, #16]	@ (800033c <EXTI2_IRQHandler+0x1c>)
 800032a:	f043 0304 	orr.w	r3, r3, #4
 800032e:	6153      	str	r3, [r2, #20]
	//Call IRQ Call
	GP_IRQ_CallBack[2]();
 8000330:	4b03      	ldr	r3, [pc, #12]	@ (8000340 <EXTI2_IRQHandler+0x20>)
 8000332:	689b      	ldr	r3, [r3, #8]
 8000334:	4798      	blx	r3
}
 8000336:	bf00      	nop
 8000338:	bd80      	pop	{r7, pc}
 800033a:	bf00      	nop
 800033c:	40010400 	.word	0x40010400
 8000340:	2000001c 	.word	0x2000001c

08000344 <EXTI3_IRQHandler>:

void EXTI3_IRQHandler(void)
{
 8000344:	b580      	push	{r7, lr}
 8000346:	af00      	add	r7, sp, #0
	//cleared by writing 1 into the bit (EXTI_PR)
	EXTI->PR |= (1<<3);
 8000348:	4b05      	ldr	r3, [pc, #20]	@ (8000360 <EXTI3_IRQHandler+0x1c>)
 800034a:	695b      	ldr	r3, [r3, #20]
 800034c:	4a04      	ldr	r2, [pc, #16]	@ (8000360 <EXTI3_IRQHandler+0x1c>)
 800034e:	f043 0308 	orr.w	r3, r3, #8
 8000352:	6153      	str	r3, [r2, #20]
	//Call IRQ Call
	GP_IRQ_CallBack[3]();
 8000354:	4b03      	ldr	r3, [pc, #12]	@ (8000364 <EXTI3_IRQHandler+0x20>)
 8000356:	68db      	ldr	r3, [r3, #12]
 8000358:	4798      	blx	r3
}
 800035a:	bf00      	nop
 800035c:	bd80      	pop	{r7, pc}
 800035e:	bf00      	nop
 8000360:	40010400 	.word	0x40010400
 8000364:	2000001c 	.word	0x2000001c

08000368 <EXTI4_IRQHandler>:

void EXTI4_IRQHandler(void)
{
 8000368:	b580      	push	{r7, lr}
 800036a:	af00      	add	r7, sp, #0
	//cleared by writing 1 into the bit (EXTI_PR)
	EXTI->PR |= (1<<4);
 800036c:	4b05      	ldr	r3, [pc, #20]	@ (8000384 <EXTI4_IRQHandler+0x1c>)
 800036e:	695b      	ldr	r3, [r3, #20]
 8000370:	4a04      	ldr	r2, [pc, #16]	@ (8000384 <EXTI4_IRQHandler+0x1c>)
 8000372:	f043 0310 	orr.w	r3, r3, #16
 8000376:	6153      	str	r3, [r2, #20]
	//Call IRQ Call
	GP_IRQ_CallBack[4]();
 8000378:	4b03      	ldr	r3, [pc, #12]	@ (8000388 <EXTI4_IRQHandler+0x20>)
 800037a:	691b      	ldr	r3, [r3, #16]
 800037c:	4798      	blx	r3
}
 800037e:	bf00      	nop
 8000380:	bd80      	pop	{r7, pc}
 8000382:	bf00      	nop
 8000384:	40010400 	.word	0x40010400
 8000388:	2000001c 	.word	0x2000001c

0800038c <EXTI9_5_IRQHandler>:

void EXTI9_5_IRQHandler(void)
{
 800038c:	b580      	push	{r7, lr}
 800038e:	af00      	add	r7, sp, #0
	if(EXTI->PR & (1<<5)){EXTI->PR |= (1<<5);	GP_IRQ_CallBack[5]();}
 8000390:	4b26      	ldr	r3, [pc, #152]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 8000392:	695b      	ldr	r3, [r3, #20]
 8000394:	f003 0320 	and.w	r3, r3, #32
 8000398:	2b00      	cmp	r3, #0
 800039a:	d008      	beq.n	80003ae <EXTI9_5_IRQHandler+0x22>
 800039c:	4b23      	ldr	r3, [pc, #140]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 800039e:	695b      	ldr	r3, [r3, #20]
 80003a0:	4a22      	ldr	r2, [pc, #136]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 80003a2:	f043 0320 	orr.w	r3, r3, #32
 80003a6:	6153      	str	r3, [r2, #20]
 80003a8:	4b21      	ldr	r3, [pc, #132]	@ (8000430 <EXTI9_5_IRQHandler+0xa4>)
 80003aa:	695b      	ldr	r3, [r3, #20]
 80003ac:	4798      	blx	r3
	if(EXTI->PR & (1<<6)){EXTI->PR |= (1<<5);	GP_IRQ_CallBack[6]();}
 80003ae:	4b1f      	ldr	r3, [pc, #124]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 80003b0:	695b      	ldr	r3, [r3, #20]
 80003b2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80003b6:	2b00      	cmp	r3, #0
 80003b8:	d008      	beq.n	80003cc <EXTI9_5_IRQHandler+0x40>
 80003ba:	4b1c      	ldr	r3, [pc, #112]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 80003bc:	695b      	ldr	r3, [r3, #20]
 80003be:	4a1b      	ldr	r2, [pc, #108]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 80003c0:	f043 0320 	orr.w	r3, r3, #32
 80003c4:	6153      	str	r3, [r2, #20]
 80003c6:	4b1a      	ldr	r3, [pc, #104]	@ (8000430 <EXTI9_5_IRQHandler+0xa4>)
 80003c8:	699b      	ldr	r3, [r3, #24]
 80003ca:	4798      	blx	r3
	if(EXTI->PR & (1<<7)){EXTI->PR |= (1<<5);	GP_IRQ_CallBack[7]();}
 80003cc:	4b17      	ldr	r3, [pc, #92]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 80003ce:	695b      	ldr	r3, [r3, #20]
 80003d0:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80003d4:	2b00      	cmp	r3, #0
 80003d6:	d008      	beq.n	80003ea <EXTI9_5_IRQHandler+0x5e>
 80003d8:	4b14      	ldr	r3, [pc, #80]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 80003da:	695b      	ldr	r3, [r3, #20]
 80003dc:	4a13      	ldr	r2, [pc, #76]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 80003de:	f043 0320 	orr.w	r3, r3, #32
 80003e2:	6153      	str	r3, [r2, #20]
 80003e4:	4b12      	ldr	r3, [pc, #72]	@ (8000430 <EXTI9_5_IRQHandler+0xa4>)
 80003e6:	69db      	ldr	r3, [r3, #28]
 80003e8:	4798      	blx	r3
	if(EXTI->PR & (1<<8)){EXTI->PR |= (1<<5);	GP_IRQ_CallBack[8]();}
 80003ea:	4b10      	ldr	r3, [pc, #64]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 80003ec:	695b      	ldr	r3, [r3, #20]
 80003ee:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80003f2:	2b00      	cmp	r3, #0
 80003f4:	d008      	beq.n	8000408 <EXTI9_5_IRQHandler+0x7c>
 80003f6:	4b0d      	ldr	r3, [pc, #52]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 80003f8:	695b      	ldr	r3, [r3, #20]
 80003fa:	4a0c      	ldr	r2, [pc, #48]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 80003fc:	f043 0320 	orr.w	r3, r3, #32
 8000400:	6153      	str	r3, [r2, #20]
 8000402:	4b0b      	ldr	r3, [pc, #44]	@ (8000430 <EXTI9_5_IRQHandler+0xa4>)
 8000404:	6a1b      	ldr	r3, [r3, #32]
 8000406:	4798      	blx	r3
	if(EXTI->PR & (1<<9)){EXTI->PR |= (1<<5);	GP_IRQ_CallBack[9]();}
 8000408:	4b08      	ldr	r3, [pc, #32]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 800040a:	695b      	ldr	r3, [r3, #20]
 800040c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8000410:	2b00      	cmp	r3, #0
 8000412:	d008      	beq.n	8000426 <EXTI9_5_IRQHandler+0x9a>
 8000414:	4b05      	ldr	r3, [pc, #20]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 8000416:	695b      	ldr	r3, [r3, #20]
 8000418:	4a04      	ldr	r2, [pc, #16]	@ (800042c <EXTI9_5_IRQHandler+0xa0>)
 800041a:	f043 0320 	orr.w	r3, r3, #32
 800041e:	6153      	str	r3, [r2, #20]
 8000420:	4b03      	ldr	r3, [pc, #12]	@ (8000430 <EXTI9_5_IRQHandler+0xa4>)
 8000422:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000424:	4798      	blx	r3
}
 8000426:	bf00      	nop
 8000428:	bd80      	pop	{r7, pc}
 800042a:	bf00      	nop
 800042c:	40010400 	.word	0x40010400
 8000430:	2000001c 	.word	0x2000001c

08000434 <EXTI15_10_IRQHandler>:

void EXTI15_10_IRQHandler(void)
{
 8000434:	b580      	push	{r7, lr}
 8000436:	af00      	add	r7, sp, #0
	if(EXTI->PR & (1<<10)){EXTI->PR |= (1<<5);	GP_IRQ_CallBack[10]();}
 8000438:	4b2d      	ldr	r3, [pc, #180]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 800043a:	695b      	ldr	r3, [r3, #20]
 800043c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8000440:	2b00      	cmp	r3, #0
 8000442:	d008      	beq.n	8000456 <EXTI15_10_IRQHandler+0x22>
 8000444:	4b2a      	ldr	r3, [pc, #168]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 8000446:	695b      	ldr	r3, [r3, #20]
 8000448:	4a29      	ldr	r2, [pc, #164]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 800044a:	f043 0320 	orr.w	r3, r3, #32
 800044e:	6153      	str	r3, [r2, #20]
 8000450:	4b28      	ldr	r3, [pc, #160]	@ (80004f4 <EXTI15_10_IRQHandler+0xc0>)
 8000452:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000454:	4798      	blx	r3
	if(EXTI->PR & (1<<11)){EXTI->PR |= (1<<5);	GP_IRQ_CallBack[11]();}
 8000456:	4b26      	ldr	r3, [pc, #152]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 8000458:	695b      	ldr	r3, [r3, #20]
 800045a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800045e:	2b00      	cmp	r3, #0
 8000460:	d008      	beq.n	8000474 <EXTI15_10_IRQHandler+0x40>
 8000462:	4b23      	ldr	r3, [pc, #140]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 8000464:	695b      	ldr	r3, [r3, #20]
 8000466:	4a22      	ldr	r2, [pc, #136]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 8000468:	f043 0320 	orr.w	r3, r3, #32
 800046c:	6153      	str	r3, [r2, #20]
 800046e:	4b21      	ldr	r3, [pc, #132]	@ (80004f4 <EXTI15_10_IRQHandler+0xc0>)
 8000470:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8000472:	4798      	blx	r3
	if(EXTI->PR & (1<<12)){EXTI->PR |= (1<<5);	GP_IRQ_CallBack[12]();}
 8000474:	4b1e      	ldr	r3, [pc, #120]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 8000476:	695b      	ldr	r3, [r3, #20]
 8000478:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 800047c:	2b00      	cmp	r3, #0
 800047e:	d008      	beq.n	8000492 <EXTI15_10_IRQHandler+0x5e>
 8000480:	4b1b      	ldr	r3, [pc, #108]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 8000482:	695b      	ldr	r3, [r3, #20]
 8000484:	4a1a      	ldr	r2, [pc, #104]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 8000486:	f043 0320 	orr.w	r3, r3, #32
 800048a:	6153      	str	r3, [r2, #20]
 800048c:	4b19      	ldr	r3, [pc, #100]	@ (80004f4 <EXTI15_10_IRQHandler+0xc0>)
 800048e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8000490:	4798      	blx	r3
	if(EXTI->PR & (1<<13)){EXTI->PR |= (1<<5);	GP_IRQ_CallBack[13]();}
 8000492:	4b17      	ldr	r3, [pc, #92]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 8000494:	695b      	ldr	r3, [r3, #20]
 8000496:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 800049a:	2b00      	cmp	r3, #0
 800049c:	d008      	beq.n	80004b0 <EXTI15_10_IRQHandler+0x7c>
 800049e:	4b14      	ldr	r3, [pc, #80]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 80004a0:	695b      	ldr	r3, [r3, #20]
 80004a2:	4a13      	ldr	r2, [pc, #76]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 80004a4:	f043 0320 	orr.w	r3, r3, #32
 80004a8:	6153      	str	r3, [r2, #20]
 80004aa:	4b12      	ldr	r3, [pc, #72]	@ (80004f4 <EXTI15_10_IRQHandler+0xc0>)
 80004ac:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80004ae:	4798      	blx	r3
	if(EXTI->PR & (1<<14)){EXTI->PR |= (1<<5);	GP_IRQ_CallBack[14]();}
 80004b0:	4b0f      	ldr	r3, [pc, #60]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 80004b2:	695b      	ldr	r3, [r3, #20]
 80004b4:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 80004b8:	2b00      	cmp	r3, #0
 80004ba:	d008      	beq.n	80004ce <EXTI15_10_IRQHandler+0x9a>
 80004bc:	4b0c      	ldr	r3, [pc, #48]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 80004be:	695b      	ldr	r3, [r3, #20]
 80004c0:	4a0b      	ldr	r2, [pc, #44]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 80004c2:	f043 0320 	orr.w	r3, r3, #32
 80004c6:	6153      	str	r3, [r2, #20]
 80004c8:	4b0a      	ldr	r3, [pc, #40]	@ (80004f4 <EXTI15_10_IRQHandler+0xc0>)
 80004ca:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80004cc:	4798      	blx	r3
	if(EXTI->PR & (1<<15)){EXTI->PR |= (1<<5);	GP_IRQ_CallBack[15]();}
 80004ce:	4b08      	ldr	r3, [pc, #32]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 80004d0:	695b      	ldr	r3, [r3, #20]
 80004d2:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80004d6:	2b00      	cmp	r3, #0
 80004d8:	d008      	beq.n	80004ec <EXTI15_10_IRQHandler+0xb8>
 80004da:	4b05      	ldr	r3, [pc, #20]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 80004dc:	695b      	ldr	r3, [r3, #20]
 80004de:	4a04      	ldr	r2, [pc, #16]	@ (80004f0 <EXTI15_10_IRQHandler+0xbc>)
 80004e0:	f043 0320 	orr.w	r3, r3, #32
 80004e4:	6153      	str	r3, [r2, #20]
 80004e6:	4b03      	ldr	r3, [pc, #12]	@ (80004f4 <EXTI15_10_IRQHandler+0xc0>)
 80004e8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80004ea:	4798      	blx	r3
}
 80004ec:	bf00      	nop
 80004ee:	bd80      	pop	{r7, pc}
 80004f0:	40010400 	.word	0x40010400
 80004f4:	2000001c 	.word	0x2000001c

080004f8 <MCAL_I2C_Init>:
 * @param [in]    -I2C_InitStruct: I2C configuration settings (clock speed, ACK, etc.).
 * @retval        -None
 * @note          -This function must be called before using the I2C.
 */
void MCAL_I2C_Init(I2C_t* I2Cx, I2C_Config_t* I2C_InitStruct)
{
 80004f8:	b5b0      	push	{r4, r5, r7, lr}
 80004fa:	b086      	sub	sp, #24
 80004fc:	af00      	add	r7, sp, #0
 80004fe:	6078      	str	r0, [r7, #4]
 8000500:	6039      	str	r1, [r7, #0]
	uint16_t tempreg = 0 , freqRenge = 0;
 8000502:	2300      	movs	r3, #0
 8000504:	82fb      	strh	r3, [r7, #22]
 8000506:	2300      	movs	r3, #0
 8000508:	82bb      	strh	r3, [r7, #20]
	uint32_t pclk1 = 8000000;
 800050a:	4b78      	ldr	r3, [pc, #480]	@ (80006ec <MCAL_I2C_Init+0x1f4>)
 800050c:	613b      	str	r3, [r7, #16]
	uint16_t result;

	//Enable RCC
	if(I2Cx == I2C1)
 800050e:	687b      	ldr	r3, [r7, #4]
 8000510:	4a77      	ldr	r2, [pc, #476]	@ (80006f0 <MCAL_I2C_Init+0x1f8>)
 8000512:	4293      	cmp	r3, r2
 8000514:	d110      	bne.n	8000538 <MCAL_I2C_Init+0x40>
	{
		Global_I2C_Config[I2C1_INDEX] = *I2C_InitStruct;
 8000516:	4a77      	ldr	r2, [pc, #476]	@ (80006f4 <MCAL_I2C_Init+0x1fc>)
 8000518:	683b      	ldr	r3, [r7, #0]
 800051a:	4614      	mov	r4, r2
 800051c:	461d      	mov	r5, r3
 800051e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000520:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000522:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000524:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000526:	682b      	ldr	r3, [r5, #0]
 8000528:	6023      	str	r3, [r4, #0]
		RCC_I2C1_CLK_EN();
 800052a:	4b73      	ldr	r3, [pc, #460]	@ (80006f8 <MCAL_I2C_Init+0x200>)
 800052c:	69db      	ldr	r3, [r3, #28]
 800052e:	4a72      	ldr	r2, [pc, #456]	@ (80006f8 <MCAL_I2C_Init+0x200>)
 8000530:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8000534:	61d3      	str	r3, [r2, #28]
 8000536:	e010      	b.n	800055a <MCAL_I2C_Init+0x62>
	}
	else
	{
		Global_I2C_Config[I2C2_INDEX] = *I2C_InitStruct;
 8000538:	4b6e      	ldr	r3, [pc, #440]	@ (80006f4 <MCAL_I2C_Init+0x1fc>)
 800053a:	683a      	ldr	r2, [r7, #0]
 800053c:	f103 0424 	add.w	r4, r3, #36	@ 0x24
 8000540:	4615      	mov	r5, r2
 8000542:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000544:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000546:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000548:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800054a:	682b      	ldr	r3, [r5, #0]
 800054c:	6023      	str	r3, [r4, #0]
		RCC_I2C2_CLK_EN();
 800054e:	4b6a      	ldr	r3, [pc, #424]	@ (80006f8 <MCAL_I2C_Init+0x200>)
 8000550:	69db      	ldr	r3, [r3, #28]
 8000552:	4a69      	ldr	r2, [pc, #420]	@ (80006f8 <MCAL_I2C_Init+0x200>)
 8000554:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8000558:	61d3      	str	r3, [r2, #28]
	}

	if(I2C_InitStruct->I2C_Mode == I2C_Mode_I2C)
 800055a:	683b      	ldr	r3, [r7, #0]
 800055c:	689b      	ldr	r3, [r3, #8]
 800055e:	2b00      	cmp	r3, #0
 8000560:	d17d      	bne.n	800065e <MCAL_I2C_Init+0x166>
	{
		//----------------------------------Init Timing---------------------------------------
		//I2C_CR2.FREQ[5:0]: Peripheral clock frequency
		tempreg = I2Cx->CR2;
 8000562:	687b      	ldr	r3, [r7, #4]
 8000564:	685b      	ldr	r3, [r3, #4]
 8000566:	82fb      	strh	r3, [r7, #22]
		//CLear Frequency FREQ[5:0] bits
		tempreg &= ~(I2C_CR2_FREQ);
 8000568:	8afb      	ldrh	r3, [r7, #22]
 800056a:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 800056e:	82fb      	strh	r3, [r7, #22]
		//Get Pclk1 Frequency value
		pclk1 = MCAL_RCC_GetPCLK1Freq();
 8000570:	f000 fc00 	bl	8000d74 <MCAL_RCC_GetPCLK1Freq>
 8000574:	6138      	str	r0, [r7, #16]
		//Set Frequency bits depending on pclk1 value
		freqRenge = (uint16_t) (pclk1 / 1000000);
 8000576:	693b      	ldr	r3, [r7, #16]
 8000578:	4a60      	ldr	r2, [pc, #384]	@ (80006fc <MCAL_I2C_Init+0x204>)
 800057a:	fba2 2303 	umull	r2, r3, r2, r3
 800057e:	0c9b      	lsrs	r3, r3, #18
 8000580:	82bb      	strh	r3, [r7, #20]
		//write to I2Cx CR2
		tempreg |= freqRenge;
 8000582:	8afa      	ldrh	r2, [r7, #22]
 8000584:	8abb      	ldrh	r3, [r7, #20]
 8000586:	4313      	orrs	r3, r2
 8000588:	82fb      	strh	r3, [r7, #22]
		//--configure the clock control registers (I2C_CCR)
		//Disable the selected I2C Peripheral to configuration Time
		I2Cx->CR1 &= ~(I2C_CR1_PE);
 800058a:	687b      	ldr	r3, [r7, #4]
 800058c:	681b      	ldr	r3, [r3, #0]
 800058e:	f023 0201 	bic.w	r2, r3, #1
 8000592:	687b      	ldr	r3, [r7, #4]
 8000594:	601a      	str	r2, [r3, #0]
		tempreg = 0;
 8000596:	2300      	movs	r3, #0
 8000598:	82fb      	strh	r3, [r7, #22]

		//Configure Speed
		if((I2C_InitStruct->I2C_ClockSpeed == I2C_SCLK_SM_50K) || (I2C_InitStruct->I2C_ClockSpeed == I2C_SCLK_SM_100K))
 800059a:	683b      	ldr	r3, [r7, #0]
 800059c:	681b      	ldr	r3, [r3, #0]
 800059e:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 80005a2:	d004      	beq.n	80005ae <MCAL_I2C_Init+0xb6>
 80005a4:	683b      	ldr	r3, [r7, #0]
 80005a6:	681b      	ldr	r3, [r3, #0]
 80005a8:	4a55      	ldr	r2, [pc, #340]	@ (8000700 <MCAL_I2C_Init+0x208>)
 80005aa:	4293      	cmp	r3, r2
 80005ac:	d112      	bne.n	80005d4 <MCAL_I2C_Init+0xdc>
		{
			//standard mode speed calculate
			//	Tclk/2 = CCR * Tpclk1
			//  CCR = Tclk / (2* I2C_ClockSpeed)
			//	CCR = Fpclk / (2* I2C_ClockSpeed)
			result = (uint16_t) (pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 80005ae:	683b      	ldr	r3, [r7, #0]
 80005b0:	681b      	ldr	r3, [r3, #0]
 80005b2:	005b      	lsls	r3, r3, #1
 80005b4:	693a      	ldr	r2, [r7, #16]
 80005b6:	fbb2 f3f3 	udiv	r3, r2, r3
 80005ba:	81fb      	strh	r3, [r7, #14]
			tempreg |= result;
 80005bc:	8afa      	ldrh	r2, [r7, #22]
 80005be:	89fb      	ldrh	r3, [r7, #14]
 80005c0:	4313      	orrs	r3, r2
 80005c2:	82fb      	strh	r3, [r7, #22]
			//write to I2Cx CCR
			I2Cx->CCR = tempreg;
 80005c4:	8afa      	ldrh	r2, [r7, #22]
 80005c6:	687b      	ldr	r3, [r7, #4]
 80005c8:	61da      	str	r2, [r3, #28]

			//I2C_TRSE Configuration
			//For instance: in Sm mode, the maximum allowed SCL rise time is 1000 ns.
			//If, in the I2C_CR2 register, the value of FREQ[5:0] bits is equal to 0x08 and TPCLK1 = 125 ns
			//therefore the TRISE[5:0] bits must be programmed with 09h.
			I2Cx->TRISE = freqRenge + 1;
 80005ca:	8abb      	ldrh	r3, [r7, #20]
 80005cc:	3301      	adds	r3, #1
 80005ce:	461a      	mov	r2, r3
 80005d0:	687b      	ldr	r3, [r7, #4]
 80005d2:	621a      	str	r2, [r3, #32]
		else
		{
			// fast mode not supported
		}
		//---------------------- I2Cx CR1 Configuration ----------------------
		tempreg = I2Cx->CR1;
 80005d4:	687b      	ldr	r3, [r7, #4]
 80005d6:	681b      	ldr	r3, [r3, #0]
 80005d8:	82fb      	strh	r3, [r7, #22]

		tempreg |= (uint16_t)(I2C_InitStruct->I2C_ACK_Control | I2C_InitStruct->General_Call_Address_Detection | I2C_InitStruct->StretchMode | I2C_InitStruct->I2C_Mode);
 80005da:	683b      	ldr	r3, [r7, #0]
 80005dc:	699b      	ldr	r3, [r3, #24]
 80005de:	b29a      	uxth	r2, r3
 80005e0:	683b      	ldr	r3, [r7, #0]
 80005e2:	69db      	ldr	r3, [r3, #28]
 80005e4:	b29b      	uxth	r3, r3
 80005e6:	4313      	orrs	r3, r2
 80005e8:	b29a      	uxth	r2, r3
 80005ea:	683b      	ldr	r3, [r7, #0]
 80005ec:	685b      	ldr	r3, [r3, #4]
 80005ee:	b29b      	uxth	r3, r3
 80005f0:	4313      	orrs	r3, r2
 80005f2:	b29a      	uxth	r2, r3
 80005f4:	683b      	ldr	r3, [r7, #0]
 80005f6:	689b      	ldr	r3, [r3, #8]
 80005f8:	b29b      	uxth	r3, r3
 80005fa:	4313      	orrs	r3, r2
 80005fc:	b29a      	uxth	r2, r3
 80005fe:	8afb      	ldrh	r3, [r7, #22]
 8000600:	4313      	orrs	r3, r2
 8000602:	82fb      	strh	r3, [r7, #22]

		I2Cx->CR1 = tempreg;
 8000604:	8afa      	ldrh	r2, [r7, #22]
 8000606:	687b      	ldr	r3, [r7, #4]
 8000608:	601a      	str	r2, [r3, #0]

		//--------------------- I2Cx OAR1 & OAR2 Configuration ----------------------
		tempreg = 0;
 800060a:	2300      	movs	r3, #0
 800060c:	82fb      	strh	r3, [r7, #22]
		if(I2C_InitStruct->I2C_Slave_Address.Dual_ADD_ack == 1)
 800060e:	683b      	ldr	r3, [r7, #0]
 8000610:	899b      	ldrh	r3, [r3, #12]
 8000612:	2b01      	cmp	r3, #1
 8000614:	d10e      	bne.n	8000634 <MCAL_I2C_Init+0x13c>
		{
			tempreg = I2C_OAR2_ENDUAL;
 8000616:	2301      	movs	r3, #1
 8000618:	82fb      	strh	r3, [r7, #22]
			tempreg |= I2C_InitStruct->I2C_Slave_Address.Secondary_slave_address << I2C_OAR2_ADD2_Pos;
 800061a:	683b      	ldr	r3, [r7, #0]
 800061c:	8a1b      	ldrh	r3, [r3, #16]
 800061e:	b21b      	sxth	r3, r3
 8000620:	005b      	lsls	r3, r3, #1
 8000622:	b21a      	sxth	r2, r3
 8000624:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8000628:	4313      	orrs	r3, r2
 800062a:	b21b      	sxth	r3, r3
 800062c:	82fb      	strh	r3, [r7, #22]
			I2Cx->OAR2 = tempreg;
 800062e:	8afa      	ldrh	r2, [r7, #22]
 8000630:	687b      	ldr	r3, [r7, #4]
 8000632:	60da      	str	r2, [r3, #12]
		}
		tempreg = 0;
 8000634:	2300      	movs	r3, #0
 8000636:	82fb      	strh	r3, [r7, #22]
		tempreg |= I2C_InitStruct->I2C_Slave_Address.Primary_slave_address << 1;
 8000638:	683b      	ldr	r3, [r7, #0]
 800063a:	89db      	ldrh	r3, [r3, #14]
 800063c:	b21b      	sxth	r3, r3
 800063e:	005b      	lsls	r3, r3, #1
 8000640:	b21a      	sxth	r2, r3
 8000642:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8000646:	4313      	orrs	r3, r2
 8000648:	b21b      	sxth	r3, r3
 800064a:	82fb      	strh	r3, [r7, #22]
		tempreg |= I2C_InitStruct->I2C_Slave_Address.I2C_Addressing_Slave_Mode;
 800064c:	683b      	ldr	r3, [r7, #0]
 800064e:	695b      	ldr	r3, [r3, #20]
 8000650:	b29a      	uxth	r2, r3
 8000652:	8afb      	ldrh	r3, [r7, #22]
 8000654:	4313      	orrs	r3, r2
 8000656:	82fb      	strh	r3, [r7, #22]
		I2Cx->OAR1 = tempreg;
 8000658:	8afa      	ldrh	r2, [r7, #22]
 800065a:	687b      	ldr	r3, [r7, #4]
 800065c:	609a      	str	r2, [r3, #8]
	{
		//SMBUS Not Supported
	}

	//Interrupt Mode (Slave Mode) //Check CallBack Pointer != NULL
	if(I2C_InitStruct->P_Slave_Event_CallBack != NULL) //that enable slave IRQ states Mode
 800065e:	683b      	ldr	r3, [r7, #0]
 8000660:	6a1b      	ldr	r3, [r3, #32]
 8000662:	2b00      	cmp	r3, #0
 8000664:	d038      	beq.n	80006d8 <MCAL_I2C_Init+0x1e0>
	{
		I2Cx->CR2 |= (I2C_CR2_ITERREN);
 8000666:	687b      	ldr	r3, [r7, #4]
 8000668:	685b      	ldr	r3, [r3, #4]
 800066a:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
 800066e:	687b      	ldr	r3, [r7, #4]
 8000670:	605a      	str	r2, [r3, #4]
		I2Cx->CR2 |= (I2C_CR2_ITEVTEN);
 8000672:	687b      	ldr	r3, [r7, #4]
 8000674:	685b      	ldr	r3, [r3, #4]
 8000676:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
 800067a:	687b      	ldr	r3, [r7, #4]
 800067c:	605a      	str	r2, [r3, #4]
		I2Cx->CR2 |= (I2C_CR2_ITBUFEN);
 800067e:	687b      	ldr	r3, [r7, #4]
 8000680:	685b      	ldr	r3, [r3, #4]
 8000682:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
 8000686:	687b      	ldr	r3, [r7, #4]
 8000688:	605a      	str	r2, [r3, #4]

		if(I2Cx == I2C1)
 800068a:	687b      	ldr	r3, [r7, #4]
 800068c:	4a18      	ldr	r2, [pc, #96]	@ (80006f0 <MCAL_I2C_Init+0x1f8>)
 800068e:	4293      	cmp	r3, r2
 8000690:	d10c      	bne.n	80006ac <MCAL_I2C_Init+0x1b4>
		{
			NVIC_IRQ31_I2C1_EV_EN;
 8000692:	4b1c      	ldr	r3, [pc, #112]	@ (8000704 <MCAL_I2C_Init+0x20c>)
 8000694:	681b      	ldr	r3, [r3, #0]
 8000696:	4a1b      	ldr	r2, [pc, #108]	@ (8000704 <MCAL_I2C_Init+0x20c>)
 8000698:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 800069c:	6013      	str	r3, [r2, #0]
			NVIC_IRQ32_I2C1_ER_EN;
 800069e:	4b1a      	ldr	r3, [pc, #104]	@ (8000708 <MCAL_I2C_Init+0x210>)
 80006a0:	681b      	ldr	r3, [r3, #0]
 80006a2:	4a19      	ldr	r2, [pc, #100]	@ (8000708 <MCAL_I2C_Init+0x210>)
 80006a4:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80006a8:	6013      	str	r3, [r2, #0]
 80006aa:	e00f      	b.n	80006cc <MCAL_I2C_Init+0x1d4>
		}
		else if(I2Cx == I2C2)
 80006ac:	687b      	ldr	r3, [r7, #4]
 80006ae:	4a17      	ldr	r2, [pc, #92]	@ (800070c <MCAL_I2C_Init+0x214>)
 80006b0:	4293      	cmp	r3, r2
 80006b2:	d10b      	bne.n	80006cc <MCAL_I2C_Init+0x1d4>
		{
			NVIC_IRQ33_I2C2_EV_EN;
 80006b4:	4b14      	ldr	r3, [pc, #80]	@ (8000708 <MCAL_I2C_Init+0x210>)
 80006b6:	681b      	ldr	r3, [r3, #0]
 80006b8:	4a13      	ldr	r2, [pc, #76]	@ (8000708 <MCAL_I2C_Init+0x210>)
 80006ba:	f043 0302 	orr.w	r3, r3, #2
 80006be:	6013      	str	r3, [r2, #0]
			NVIC_IRQ34_I2C2_ER_EN;
 80006c0:	4b11      	ldr	r3, [pc, #68]	@ (8000708 <MCAL_I2C_Init+0x210>)
 80006c2:	681b      	ldr	r3, [r3, #0]
 80006c4:	4a10      	ldr	r2, [pc, #64]	@ (8000708 <MCAL_I2C_Init+0x210>)
 80006c6:	f043 0304 	orr.w	r3, r3, #4
 80006ca:	6013      	str	r3, [r2, #0]
		}
		I2Cx->SR1 = 0;
 80006cc:	687b      	ldr	r3, [r7, #4]
 80006ce:	2200      	movs	r2, #0
 80006d0:	615a      	str	r2, [r3, #20]
		I2Cx->SR2 = 0;
 80006d2:	687b      	ldr	r3, [r7, #4]
 80006d4:	2200      	movs	r2, #0
 80006d6:	619a      	str	r2, [r3, #24]
	}

	//Enable the selected I2C prepheral
	I2Cx->CR1 |= I2C_CR1_PE;
 80006d8:	687b      	ldr	r3, [r7, #4]
 80006da:	681b      	ldr	r3, [r3, #0]
 80006dc:	f043 0201 	orr.w	r2, r3, #1
 80006e0:	687b      	ldr	r3, [r7, #4]
 80006e2:	601a      	str	r2, [r3, #0]
}
 80006e4:	bf00      	nop
 80006e6:	3718      	adds	r7, #24
 80006e8:	46bd      	mov	sp, r7
 80006ea:	bdb0      	pop	{r4, r5, r7, pc}
 80006ec:	007a1200 	.word	0x007a1200
 80006f0:	40005400 	.word	0x40005400
 80006f4:	20000058 	.word	0x20000058
 80006f8:	40021000 	.word	0x40021000
 80006fc:	431bde83 	.word	0x431bde83
 8000700:	000186a0 	.word	0x000186a0
 8000704:	e000e100 	.word	0xe000e100
 8000708:	e000e104 	.word	0xe000e104
 800070c:	40005800 	.word	0x40005800

08000710 <MCAL_I2C_GPIO_Set_Pins>:
 * @param [in]    -I2Cx: Choose which I2C instance (e.g., I2C1 or I2C2).
 * @retval        -None
 * @note          -Must be called before I2C initialization.
 */
void MCAL_I2C_GPIO_Set_Pins(I2C_t* I2Cx)
{
 8000710:	b580      	push	{r7, lr}
 8000712:	b084      	sub	sp, #16
 8000714:	af00      	add	r7, sp, #0
 8000716:	6078      	str	r0, [r7, #4]
	GPIO_Config_t pincfg;

	if(I2Cx == I2C1)
 8000718:	687b      	ldr	r3, [r7, #4]
 800071a:	4a1f      	ldr	r2, [pc, #124]	@ (8000798 <MCAL_I2C_GPIO_Set_Pins+0x88>)
 800071c:	4293      	cmp	r3, r2
 800071e:	d118      	bne.n	8000752 <MCAL_I2C_GPIO_Set_Pins+0x42>
	{
		//PB6 : I2C_SCL
		//PB7 : I2C_SDA

		pincfg.GPIO_PinMode = GPIO_MODE_OUTPUT_AF_OD;
 8000720:	2307      	movs	r3, #7
 8000722:	817b      	strh	r3, [r7, #10]
		pincfg.GPIO_PinNumber = GPIO_PIN_6;
 8000724:	2340      	movs	r3, #64	@ 0x40
 8000726:	813b      	strh	r3, [r7, #8]
		pincfg.GPIO_PinSpeed = GPIO_SPEED_10MHz;
 8000728:	2301      	movs	r3, #1
 800072a:	81bb      	strh	r3, [r7, #12]
		MCAL_GPIO_Init(GPIOB, &pincfg);
 800072c:	f107 0308 	add.w	r3, r7, #8
 8000730:	4619      	mov	r1, r3
 8000732:	481a      	ldr	r0, [pc, #104]	@ (800079c <MCAL_I2C_GPIO_Set_Pins+0x8c>)
 8000734:	f000 fc78 	bl	8001028 <MCAL_GPIO_Init>

		pincfg.GPIO_PinMode = GPIO_MODE_OUTPUT_AF_OD;
 8000738:	2307      	movs	r3, #7
 800073a:	817b      	strh	r3, [r7, #10]
		pincfg.GPIO_PinNumber = GPIO_PIN_7;
 800073c:	2380      	movs	r3, #128	@ 0x80
 800073e:	813b      	strh	r3, [r7, #8]
		pincfg.GPIO_PinSpeed = GPIO_SPEED_10MHz;
 8000740:	2301      	movs	r3, #1
 8000742:	81bb      	strh	r3, [r7, #12]
		MCAL_GPIO_Init(GPIOB, &pincfg);
 8000744:	f107 0308 	add.w	r3, r7, #8
 8000748:	4619      	mov	r1, r3
 800074a:	4814      	ldr	r0, [pc, #80]	@ (800079c <MCAL_I2C_GPIO_Set_Pins+0x8c>)
 800074c:	f000 fc6c 	bl	8001028 <MCAL_GPIO_Init>
		pincfg.GPIO_PinMode = GPIO_MODE_OUTPUT_AF_OD;
		pincfg.GPIO_PinNumber = GPIO_PIN_11;
		pincfg.GPIO_PinSpeed = GPIO_SPEED_10MHz;
		MCAL_GPIO_Init(GPIOB, &pincfg);
	}
}
 8000750:	e01d      	b.n	800078e <MCAL_I2C_GPIO_Set_Pins+0x7e>
	else if(I2Cx == I2C2)
 8000752:	687b      	ldr	r3, [r7, #4]
 8000754:	4a12      	ldr	r2, [pc, #72]	@ (80007a0 <MCAL_I2C_GPIO_Set_Pins+0x90>)
 8000756:	4293      	cmp	r3, r2
 8000758:	d119      	bne.n	800078e <MCAL_I2C_GPIO_Set_Pins+0x7e>
		pincfg.GPIO_PinMode = GPIO_MODE_OUTPUT_AF_OD;
 800075a:	2307      	movs	r3, #7
 800075c:	817b      	strh	r3, [r7, #10]
		pincfg.GPIO_PinNumber = GPIO_PIN_10;
 800075e:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8000762:	813b      	strh	r3, [r7, #8]
		pincfg.GPIO_PinSpeed = GPIO_SPEED_10MHz;
 8000764:	2301      	movs	r3, #1
 8000766:	81bb      	strh	r3, [r7, #12]
		MCAL_GPIO_Init(GPIOB, &pincfg);
 8000768:	f107 0308 	add.w	r3, r7, #8
 800076c:	4619      	mov	r1, r3
 800076e:	480b      	ldr	r0, [pc, #44]	@ (800079c <MCAL_I2C_GPIO_Set_Pins+0x8c>)
 8000770:	f000 fc5a 	bl	8001028 <MCAL_GPIO_Init>
		pincfg.GPIO_PinMode = GPIO_MODE_OUTPUT_AF_OD;
 8000774:	2307      	movs	r3, #7
 8000776:	817b      	strh	r3, [r7, #10]
		pincfg.GPIO_PinNumber = GPIO_PIN_11;
 8000778:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 800077c:	813b      	strh	r3, [r7, #8]
		pincfg.GPIO_PinSpeed = GPIO_SPEED_10MHz;
 800077e:	2301      	movs	r3, #1
 8000780:	81bb      	strh	r3, [r7, #12]
		MCAL_GPIO_Init(GPIOB, &pincfg);
 8000782:	f107 0308 	add.w	r3, r7, #8
 8000786:	4619      	mov	r1, r3
 8000788:	4804      	ldr	r0, [pc, #16]	@ (800079c <MCAL_I2C_GPIO_Set_Pins+0x8c>)
 800078a:	f000 fc4d 	bl	8001028 <MCAL_GPIO_Init>
}
 800078e:	bf00      	nop
 8000790:	3710      	adds	r7, #16
 8000792:	46bd      	mov	sp, r7
 8000794:	bd80      	pop	{r7, pc}
 8000796:	bf00      	nop
 8000798:	40005400 	.word	0x40005400
 800079c:	40010c00 	.word	0x40010c00
 80007a0:	40005800 	.word	0x40005800

080007a4 <MCAL_I2C_Master_TX>:
 * @param [in]    -Start: Repeated start condition configuration.
 * @retval        -None
 * @note          -This function generates START, sends data, and optionally generates STOP.
 */
void MCAL_I2C_Master_TX(I2C_t* I2Cx, uint16_t devAdder, uint8_t* dataOut, uint32_t dataLen, Stop_Condition Stop, Repeated_Start Start)
{
 80007a4:	b580      	push	{r7, lr}
 80007a6:	b086      	sub	sp, #24
 80007a8:	af00      	add	r7, sp, #0
 80007aa:	60f8      	str	r0, [r7, #12]
 80007ac:	607a      	str	r2, [r7, #4]
 80007ae:	603b      	str	r3, [r7, #0]
 80007b0:	460b      	mov	r3, r1
 80007b2:	817b      	strh	r3, [r7, #10]
	int i=0;
 80007b4:	2300      	movs	r3, #0
 80007b6:	617b      	str	r3, [r7, #20]
	//todo Support Timeout (Configure timer working for specific duration rise interrupt)
	//timer_interrupt(){flag=1}
	//so any code exist in while (check flag || any polling condition)
	//1.Set the Start bit in the I2C_CR1 register to generate a start condition
	I2C_GenerateStart(I2Cx, ENABLE, Start);
 80007b8:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 80007bc:	461a      	mov	r2, r3
 80007be:	2101      	movs	r1, #1
 80007c0:	68f8      	ldr	r0, [r7, #12]
 80007c2:	f000 f863 	bl	800088c <I2C_GenerateStart>
	//2.Wait for EV5
	// EV5: SB=1, cleared by reading SR1 register followed by writing DR register with Address.
	while(!I2C_GetFlagStatus(I2Cx, EV5));
 80007c6:	bf00      	nop
 80007c8:	2101      	movs	r1, #1
 80007ca:	68f8      	ldr	r0, [r7, #12]
 80007cc:	f000 f8a6 	bl	800091c <I2C_GetFlagStatus>
 80007d0:	4603      	mov	r3, r0
 80007d2:	2b00      	cmp	r3, #0
 80007d4:	d0f8      	beq.n	80007c8 <MCAL_I2C_Master_TX+0x24>

	//3.Send Address
	I2C_SendAddress(I2Cx, devAdder, I2C_Direction_Transmitter);
 80007d6:	897b      	ldrh	r3, [r7, #10]
 80007d8:	2200      	movs	r2, #0
 80007da:	4619      	mov	r1, r3
 80007dc:	68f8      	ldr	r0, [r7, #12]
 80007de:	f000 f836 	bl	800084e <I2C_SendAddress>

	//4.Wait for EV6
	//EV6: ADDR=1, cleared by reading SR1 register followed by reading SR2.
	while(!I2C_GetFlagStatus(I2Cx, EV6));
 80007e2:	bf00      	nop
 80007e4:	2102      	movs	r1, #2
 80007e6:	68f8      	ldr	r0, [r7, #12]
 80007e8:	f000 f898 	bl	800091c <I2C_GetFlagStatus>
 80007ec:	4603      	mov	r3, r0
 80007ee:	2b00      	cmp	r3, #0
 80007f0:	d0f8      	beq.n	80007e4 <MCAL_I2C_Master_TX+0x40>

	//5.TRA, MSL, TXE, BUSY flags //in Status REG
	while(!I2C_GetFlagStatus(I2Cx, MASTER_BYTE_TRANSMITTING));
 80007f2:	bf00      	nop
 80007f4:	f44f 21e0 	mov.w	r1, #458752	@ 0x70000
 80007f8:	68f8      	ldr	r0, [r7, #12]
 80007fa:	f000 f88f 	bl	800091c <I2C_GetFlagStatus>
 80007fe:	4603      	mov	r3, r0
 8000800:	2b00      	cmp	r3, #0
 8000802:	d0f7      	beq.n	80007f4 <MCAL_I2C_Master_TX+0x50>

	for(i = 0 ; i < dataLen ; i++)
 8000804:	2300      	movs	r3, #0
 8000806:	617b      	str	r3, [r7, #20]
 8000808:	e011      	b.n	800082e <MCAL_I2C_Master_TX+0x8a>
	{
		//Write in the DR register the data to be sent
		I2Cx->DR = dataOut[i];
 800080a:	697b      	ldr	r3, [r7, #20]
 800080c:	687a      	ldr	r2, [r7, #4]
 800080e:	4413      	add	r3, r2
 8000810:	781b      	ldrb	r3, [r3, #0]
 8000812:	461a      	mov	r2, r3
 8000814:	68fb      	ldr	r3, [r7, #12]
 8000816:	611a      	str	r2, [r3, #16]
		//6.Wait for EV8
		// EV8: TxE=1, shift register not empty, data register empty, cleared by writing DR register
		while(!I2C_GetFlagStatus(I2Cx, EV8));
 8000818:	bf00      	nop
 800081a:	2103      	movs	r1, #3
 800081c:	68f8      	ldr	r0, [r7, #12]
 800081e:	f000 f87d 	bl	800091c <I2C_GetFlagStatus>
 8000822:	4603      	mov	r3, r0
 8000824:	2b00      	cmp	r3, #0
 8000826:	d0f8      	beq.n	800081a <MCAL_I2C_Master_TX+0x76>
	for(i = 0 ; i < dataLen ; i++)
 8000828:	697b      	ldr	r3, [r7, #20]
 800082a:	3301      	adds	r3, #1
 800082c:	617b      	str	r3, [r7, #20]
 800082e:	697b      	ldr	r3, [r7, #20]
 8000830:	683a      	ldr	r2, [r7, #0]
 8000832:	429a      	cmp	r2, r3
 8000834:	d8e9      	bhi.n	800080a <MCAL_I2C_Master_TX+0x66>
	//7.Wait EV8_2
	// EV8_1: TxE=1, shift register empty, data register empty, write Data1 in DR.
	//while(!I2C_GetFlagStatus(I2Cx, EV8_2));

	//8.Send Stop condition
	if(Stop != Without_Stop) I2C_GenerateSTOP(I2Cx, ENABLE);
 8000836:	f897 3020 	ldrb.w	r3, [r7, #32]
 800083a:	2b01      	cmp	r3, #1
 800083c:	d003      	beq.n	8000846 <MCAL_I2C_Master_TX+0xa2>
 800083e:	2101      	movs	r1, #1
 8000840:	68f8      	ldr	r0, [r7, #12]
 8000842:	f000 f84a 	bl	80008da <I2C_GenerateSTOP>
}
 8000846:	bf00      	nop
 8000848:	3718      	adds	r7, #24
 800084a:	46bd      	mov	sp, r7
 800084c:	bd80      	pop	{r7, pc}

0800084e <I2C_SendAddress>:

void I2C_SendAddress(I2C_t* I2Cx , uint16_t Address, I2C_Direction Direction)
{
 800084e:	b480      	push	{r7}
 8000850:	b083      	sub	sp, #12
 8000852:	af00      	add	r7, sp, #0
 8000854:	6078      	str	r0, [r7, #4]
 8000856:	460b      	mov	r3, r1
 8000858:	807b      	strh	r3, [r7, #2]
 800085a:	4613      	mov	r3, r2
 800085c:	707b      	strb	r3, [r7, #1]
	Address = (Address << 1);
 800085e:	887b      	ldrh	r3, [r7, #2]
 8000860:	005b      	lsls	r3, r3, #1
 8000862:	807b      	strh	r3, [r7, #2]

	if(Direction != I2C_Direction_Transmitter)
 8000864:	787b      	ldrb	r3, [r7, #1]
 8000866:	2b00      	cmp	r3, #0
 8000868:	d004      	beq.n	8000874 <I2C_SendAddress+0x26>
	{
		//set the address bit0 for read
		Address |= 1<<0;
 800086a:	887b      	ldrh	r3, [r7, #2]
 800086c:	f043 0301 	orr.w	r3, r3, #1
 8000870:	807b      	strh	r3, [r7, #2]
 8000872:	e003      	b.n	800087c <I2C_SendAddress+0x2e>
	}
	else
	{
		//reset the address bit0 for write
		Address &= ~(1<<0);
 8000874:	887b      	ldrh	r3, [r7, #2]
 8000876:	f023 0301 	bic.w	r3, r3, #1
 800087a:	807b      	strh	r3, [r7, #2]
	}

	//send the address
	I2Cx->DR = Address;
 800087c:	887a      	ldrh	r2, [r7, #2]
 800087e:	687b      	ldr	r3, [r7, #4]
 8000880:	611a      	str	r2, [r3, #16]
}
 8000882:	bf00      	nop
 8000884:	370c      	adds	r7, #12
 8000886:	46bd      	mov	sp, r7
 8000888:	bc80      	pop	{r7}
 800088a:	4770      	bx	lr

0800088c <I2C_GenerateStart>:


void I2C_GenerateStart(I2C_t* I2Cx, FunctionalState NewStart, Repeated_Start Start)
{
 800088c:	b580      	push	{r7, lr}
 800088e:	b082      	sub	sp, #8
 8000890:	af00      	add	r7, sp, #0
 8000892:	6078      	str	r0, [r7, #4]
 8000894:	460b      	mov	r3, r1
 8000896:	70fb      	strb	r3, [r7, #3]
 8000898:	4613      	mov	r3, r2
 800089a:	70bb      	strb	r3, [r7, #2]
	if(Start != repeated_Start)
 800089c:	78bb      	ldrb	r3, [r7, #2]
 800089e:	2b01      	cmp	r3, #1
 80008a0:	d007      	beq.n	80008b2 <I2C_GenerateStart+0x26>
	{
		//Check if the Bus is idle
		while(I2C_GetFlagStatus(I2Cx, I2C_FLAG_BUSY));
 80008a2:	bf00      	nop
 80008a4:	2100      	movs	r1, #0
 80008a6:	6878      	ldr	r0, [r7, #4]
 80008a8:	f000 f838 	bl	800091c <I2C_GetFlagStatus>
 80008ac:	4603      	mov	r3, r0
 80008ae:	2b00      	cmp	r3, #0
 80008b0:	d1f8      	bne.n	80008a4 <I2C_GenerateStart+0x18>
	//0: No Start generation
	//1: Repeated start generation
	//In Slave mode:
	//0: No Start generation
	//1: Start generation when the bus is free
	if(NewStart != DISABLE) I2Cx->CR1 |= I2C_CR1_START;
 80008b2:	78fb      	ldrb	r3, [r7, #3]
 80008b4:	2b00      	cmp	r3, #0
 80008b6:	d006      	beq.n	80008c6 <I2C_GenerateStart+0x3a>
 80008b8:	687b      	ldr	r3, [r7, #4]
 80008ba:	681b      	ldr	r3, [r3, #0]
 80008bc:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
 80008c0:	687b      	ldr	r3, [r7, #4]
 80008c2:	601a      	str	r2, [r3, #0]
	else I2Cx->CR1 &= ~(I2C_CR1_START);

}
 80008c4:	e005      	b.n	80008d2 <I2C_GenerateStart+0x46>
	else I2Cx->CR1 &= ~(I2C_CR1_START);
 80008c6:	687b      	ldr	r3, [r7, #4]
 80008c8:	681b      	ldr	r3, [r3, #0]
 80008ca:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
 80008ce:	687b      	ldr	r3, [r7, #4]
 80008d0:	601a      	str	r2, [r3, #0]
}
 80008d2:	bf00      	nop
 80008d4:	3708      	adds	r7, #8
 80008d6:	46bd      	mov	sp, r7
 80008d8:	bd80      	pop	{r7, pc}

080008da <I2C_GenerateSTOP>:

void I2C_GenerateSTOP(I2C_t* I2Cx, FunctionalState NewState)
{
 80008da:	b480      	push	{r7}
 80008dc:	b083      	sub	sp, #12
 80008de:	af00      	add	r7, sp, #0
 80008e0:	6078      	str	r0, [r7, #4]
 80008e2:	460b      	mov	r3, r1
 80008e4:	70fb      	strb	r3, [r7, #3]
	// Bit 9 STOP: Stop generation
	if(NewState == ENABLE)
 80008e6:	78fb      	ldrb	r3, [r7, #3]
 80008e8:	2b01      	cmp	r3, #1
 80008ea:	d10c      	bne.n	8000906 <I2C_GenerateSTOP+0x2c>
	{
		//Generate a STOP Condition
		I2Cx->CR1 |= I2C_CR1_STOP;
 80008ec:	687b      	ldr	r3, [r7, #4]
 80008ee:	681b      	ldr	r3, [r3, #0]
 80008f0:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
 80008f4:	687b      	ldr	r3, [r7, #4]
 80008f6:	601a      	str	r2, [r3, #0]
		I2Cx->SR2 &= ~(I2C_SR2_BUSY);
 80008f8:	687b      	ldr	r3, [r7, #4]
 80008fa:	699b      	ldr	r3, [r3, #24]
 80008fc:	f023 0202 	bic.w	r2, r3, #2
 8000900:	687b      	ldr	r3, [r7, #4]
 8000902:	619a      	str	r2, [r3, #24]
	{
		//Disable the STOP Condition Generation
		I2Cx->CR1 &= ~(I2C_CR1_STOP);
	}

}
 8000904:	e005      	b.n	8000912 <I2C_GenerateSTOP+0x38>
		I2Cx->CR1 &= ~(I2C_CR1_STOP);
 8000906:	687b      	ldr	r3, [r7, #4]
 8000908:	681b      	ldr	r3, [r3, #0]
 800090a:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
 800090e:	687b      	ldr	r3, [r7, #4]
 8000910:	601a      	str	r2, [r3, #0]
}
 8000912:	bf00      	nop
 8000914:	370c      	adds	r7, #12
 8000916:	46bd      	mov	sp, r7
 8000918:	bc80      	pop	{r7}
 800091a:	4770      	bx	lr

0800091c <I2C_GetFlagStatus>:


FlagStatus I2C_GetFlagStatus(I2C_t* I2Cx, Status Flag)
{
 800091c:	b480      	push	{r7}
 800091e:	b089      	sub	sp, #36	@ 0x24
 8000920:	af00      	add	r7, sp, #0
 8000922:	6078      	str	r0, [r7, #4]
 8000924:	6039      	str	r1, [r7, #0]
	volatile uint32_t dummyRead;
	uint32_t flag1 , flag2 , lastEvent=0;
 8000926:	2300      	movs	r3, #0
 8000928:	61bb      	str	r3, [r7, #24]
	FlagStatus bitStatus = RESET;
 800092a:	2300      	movs	r3, #0
 800092c:	77fb      	strb	r3, [r7, #31]

	switch(Flag)
 800092e:	683b      	ldr	r3, [r7, #0]
 8000930:	2b06      	cmp	r3, #6
 8000932:	d813      	bhi.n	800095c <I2C_GetFlagStatus+0x40>
 8000934:	683b      	ldr	r3, [r7, #0]
 8000936:	2b06      	cmp	r3, #6
 8000938:	d86f      	bhi.n	8000a1a <I2C_GetFlagStatus+0xfe>
 800093a:	a201      	add	r2, pc, #4	@ (adr r2, 8000940 <I2C_GetFlagStatus+0x24>)
 800093c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000940:	08000967 	.word	0x08000967
 8000944:	0800097f 	.word	0x0800097f
 8000948:	08000997 	.word	0x08000997
 800094c:	080009eb 	.word	0x080009eb
 8000950:	080009eb 	.word	0x080009eb
 8000954:	08000a1b 	.word	0x08000a1b
 8000958:	08000a03 	.word	0x08000a03
 800095c:	683b      	ldr	r3, [r7, #0]
 800095e:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
 8000962:	d027      	beq.n	80009b4 <I2C_GetFlagStatus+0x98>
 8000964:	e059      	b.n	8000a1a <I2C_GetFlagStatus+0xfe>
	case I2C_FLAG_BUSY:
		//0: No communication on the bus
		//1: Communication ongoing on the bus– Set by hardware on detection of SDA or SCL low – cleared by hardware on detection of a Stop condition.
		//It indicates a communication in progress on the bus. This information is still updated when
		//the interface is disabled (PE=0).
		if((I2Cx->SR2) & (I2C_SR2_BUSY)) bitStatus = SET;
 8000966:	687b      	ldr	r3, [r7, #4]
 8000968:	699b      	ldr	r3, [r3, #24]
 800096a:	f003 0302 	and.w	r3, r3, #2
 800096e:	2b00      	cmp	r3, #0
 8000970:	d002      	beq.n	8000978 <I2C_GetFlagStatus+0x5c>
 8000972:	2301      	movs	r3, #1
 8000974:	77fb      	strb	r3, [r7, #31]
		else bitStatus = RESET;
		break;
 8000976:	e050      	b.n	8000a1a <I2C_GetFlagStatus+0xfe>
		else bitStatus = RESET;
 8000978:	2300      	movs	r3, #0
 800097a:	77fb      	strb	r3, [r7, #31]
		break;
 800097c:	e04d      	b.n	8000a1a <I2C_GetFlagStatus+0xfe>
		// EV5: SB=1, cleared by reading SR1 register followed by writing DR register with Address.
		//Bit 0 SB: Start bit (Master mode)
		//0: No Start condition
		//1: Start condition generated.– Set when a Start condition generated.– Cleared by software by reading the SR1 register followed by writing the DR register, or by
		//hardware when PE=0
		if((I2Cx->SR1) & (I2C_SR1_SB)) bitStatus = SET;
 800097e:	687b      	ldr	r3, [r7, #4]
 8000980:	695b      	ldr	r3, [r3, #20]
 8000982:	f003 0301 	and.w	r3, r3, #1
 8000986:	2b00      	cmp	r3, #0
 8000988:	d002      	beq.n	8000990 <I2C_GetFlagStatus+0x74>
 800098a:	2301      	movs	r3, #1
 800098c:	77fb      	strb	r3, [r7, #31]
		else bitStatus = RESET;
		break;
 800098e:	e044      	b.n	8000a1a <I2C_GetFlagStatus+0xfe>
		else bitStatus = RESET;
 8000990:	2300      	movs	r3, #0
 8000992:	77fb      	strb	r3, [r7, #31]
		break;
 8000994:	e041      	b.n	8000a1a <I2C_GetFlagStatus+0xfe>
	case EV6:
		// EV6: ADDR=1, cleared by reading SR1 register followed by reading SR2.
		// Bit 1 ADDR: Address sent (master mode)/matched (slave mode)
		if((I2Cx->SR1) & (I2C_SR1_ADDR)) bitStatus = SET;
 8000996:	687b      	ldr	r3, [r7, #4]
 8000998:	695b      	ldr	r3, [r3, #20]
 800099a:	f003 0302 	and.w	r3, r3, #2
 800099e:	2b00      	cmp	r3, #0
 80009a0:	d002      	beq.n	80009a8 <I2C_GetFlagStatus+0x8c>
 80009a2:	2301      	movs	r3, #1
 80009a4:	77fb      	strb	r3, [r7, #31]
 80009a6:	e001      	b.n	80009ac <I2C_GetFlagStatus+0x90>
		else bitStatus = RESET;
 80009a8:	2300      	movs	r3, #0
 80009aa:	77fb      	strb	r3, [r7, #31]
		dummyRead = I2Cx->SR2;
 80009ac:	687b      	ldr	r3, [r7, #4]
 80009ae:	699b      	ldr	r3, [r3, #24]
 80009b0:	60fb      	str	r3, [r7, #12]
		break;
 80009b2:	e032      	b.n	8000a1a <I2C_GetFlagStatus+0xfe>
	case MASTER_BYTE_TRANSMITTING:
		//read the I2Cx status register
		flag1 = I2Cx->SR1;
 80009b4:	687b      	ldr	r3, [r7, #4]
 80009b6:	695b      	ldr	r3, [r3, #20]
 80009b8:	617b      	str	r3, [r7, #20]
		flag2 = I2Cx->SR2;
 80009ba:	687b      	ldr	r3, [r7, #4]
 80009bc:	699b      	ldr	r3, [r3, #24]
 80009be:	613b      	str	r3, [r7, #16]
		flag2 = flag2<<16;
 80009c0:	693b      	ldr	r3, [r7, #16]
 80009c2:	041b      	lsls	r3, r3, #16
 80009c4:	613b      	str	r3, [r7, #16]
		//get the last event value from I2C status register
		lastEvent = (flag1 | flag2) & ((uint32_t)0x00FFFFFF);
 80009c6:	697a      	ldr	r2, [r7, #20]
 80009c8:	693b      	ldr	r3, [r7, #16]
 80009ca:	4313      	orrs	r3, r2
 80009cc:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 80009d0:	61bb      	str	r3, [r7, #24]
		//Check Whether the last event is equal to I2C_EVENT
		if((lastEvent & Flag) == Flag)
 80009d2:	69ba      	ldr	r2, [r7, #24]
 80009d4:	683b      	ldr	r3, [r7, #0]
 80009d6:	4013      	ands	r3, r2
 80009d8:	683a      	ldr	r2, [r7, #0]
 80009da:	429a      	cmp	r2, r3
 80009dc:	d102      	bne.n	80009e4 <I2C_GetFlagStatus+0xc8>
		{
			//SUCCRSS: last event is equal to I2C_EVENT
			bitStatus = SET;
 80009de:	2301      	movs	r3, #1
 80009e0:	77fb      	strb	r3, [r7, #31]
		else
		{
			//ERROR: last event is equal to I2C_EVENT
			bitStatus = RESET;
		}
		break;
 80009e2:	e01a      	b.n	8000a1a <I2C_GetFlagStatus+0xfe>
			bitStatus = RESET;
 80009e4:	2300      	movs	r3, #0
 80009e6:	77fb      	strb	r3, [r7, #31]
		break;
 80009e8:	e017      	b.n	8000a1a <I2C_GetFlagStatus+0xfe>
	case EV8_1:
	case EV8:
		//Bit 7 TxE: Data register empty (transmitters)
		//0: Data register not empty
		//1: Data register empty
		if((I2Cx->SR1) & (I2C_SR1_TXE)) bitStatus = SET;
 80009ea:	687b      	ldr	r3, [r7, #4]
 80009ec:	695b      	ldr	r3, [r3, #20]
 80009ee:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80009f2:	2b00      	cmp	r3, #0
 80009f4:	d002      	beq.n	80009fc <I2C_GetFlagStatus+0xe0>
 80009f6:	2301      	movs	r3, #1
 80009f8:	77fb      	strb	r3, [r7, #31]
		else bitStatus = RESET;
		break;
 80009fa:	e00e      	b.n	8000a1a <I2C_GetFlagStatus+0xfe>
		else bitStatus = RESET;
 80009fc:	2300      	movs	r3, #0
 80009fe:	77fb      	strb	r3, [r7, #31]
		break;
 8000a00:	e00b      	b.n	8000a1a <I2C_GetFlagStatus+0xfe>
	case EV7:
		//Bit 6 RxNE: Data register not empty (receivers)
		//0: Data register empty
		//1: Data register not empty– Set when data register is not empty in receiver mode. RxNE is not set during address phase.– Cleared by software reading or writing the DR register or by hardware when PE=0.
		//RxNE is not set in case of ARLO event.
		if((I2Cx->SR1) & (I2C_SR1_RXNE)) bitStatus = SET;
 8000a02:	687b      	ldr	r3, [r7, #4]
 8000a04:	695b      	ldr	r3, [r3, #20]
 8000a06:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8000a0a:	2b00      	cmp	r3, #0
 8000a0c:	d002      	beq.n	8000a14 <I2C_GetFlagStatus+0xf8>
 8000a0e:	2301      	movs	r3, #1
 8000a10:	77fb      	strb	r3, [r7, #31]
		else bitStatus = RESET;
		break;
 8000a12:	e001      	b.n	8000a18 <I2C_GetFlagStatus+0xfc>
		else bitStatus = RESET;
 8000a14:	2300      	movs	r3, #0
 8000a16:	77fb      	strb	r3, [r7, #31]
		break;
 8000a18:	bf00      	nop
	}

	return bitStatus;
 8000a1a:	7ffb      	ldrb	r3, [r7, #31]
}
 8000a1c:	4618      	mov	r0, r3
 8000a1e:	3724      	adds	r7, #36	@ 0x24
 8000a20:	46bd      	mov	sp, r7
 8000a22:	bc80      	pop	{r7}
 8000a24:	4770      	bx	lr
 8000a26:	bf00      	nop

08000a28 <MCAL_I2C_Master_RX>:
 * @param [in]    -Start: Repeated start condition configuration.
 * @retval        -None
 * @note          -This function generates START, receives data, and optionally generates STOP.
 */
void MCAL_I2C_Master_RX(I2C_t* I2Cx, uint16_t devAdder, uint8_t* dataOut, uint32_t dataLen, Stop_Condition Stop, Repeated_Start Start)
{
 8000a28:	b580      	push	{r7, lr}
 8000a2a:	b086      	sub	sp, #24
 8000a2c:	af00      	add	r7, sp, #0
 8000a2e:	60f8      	str	r0, [r7, #12]
 8000a30:	607a      	str	r2, [r7, #4]
 8000a32:	603b      	str	r3, [r7, #0]
 8000a34:	460b      	mov	r3, r1
 8000a36:	817b      	strh	r3, [r7, #10]
	uint8_t index = I2Cx == I2C1 ? I2C1_INDEX :  I2C2_INDEX;
 8000a38:	68fb      	ldr	r3, [r7, #12]
 8000a3a:	4a39      	ldr	r2, [pc, #228]	@ (8000b20 <MCAL_I2C_Master_RX+0xf8>)
 8000a3c:	4293      	cmp	r3, r2
 8000a3e:	bf14      	ite	ne
 8000a40:	2301      	movne	r3, #1
 8000a42:	2300      	moveq	r3, #0
 8000a44:	b2db      	uxtb	r3, r3
 8000a46:	74fb      	strb	r3, [r7, #19]

	int i=0;
 8000a48:	2300      	movs	r3, #0
 8000a4a:	617b      	str	r3, [r7, #20]
	//todo Support Timeout (Configure timer working for specific duration rise interrupt)
	//timer_interrupt(){flag=1}
	//so any code exist in while (check flag || any polling condition)
	//1.Set the Start bit in the I2C_CR1 register to generate a start condition
	I2C_GenerateStart(I2Cx, ENABLE, Start);
 8000a4c:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 8000a50:	461a      	mov	r2, r3
 8000a52:	2101      	movs	r1, #1
 8000a54:	68f8      	ldr	r0, [r7, #12]
 8000a56:	f7ff ff19 	bl	800088c <I2C_GenerateStart>
	//2.Wait for EV5
	// EV5: SB=1, cleared by reading SR1 register followed by writing DR register with Address.
	while(!I2C_GetFlagStatus(I2Cx, EV5));
 8000a5a:	bf00      	nop
 8000a5c:	2101      	movs	r1, #1
 8000a5e:	68f8      	ldr	r0, [r7, #12]
 8000a60:	f7ff ff5c 	bl	800091c <I2C_GetFlagStatus>
 8000a64:	4603      	mov	r3, r0
 8000a66:	2b00      	cmp	r3, #0
 8000a68:	d0f8      	beq.n	8000a5c <MCAL_I2C_Master_RX+0x34>

	//3.Send Address
	I2C_SendAddress(I2Cx, devAdder, I2C_Direction_Reciever);
 8000a6a:	897b      	ldrh	r3, [r7, #10]
 8000a6c:	2201      	movs	r2, #1
 8000a6e:	4619      	mov	r1, r3
 8000a70:	68f8      	ldr	r0, [r7, #12]
 8000a72:	f7ff feec 	bl	800084e <I2C_SendAddress>

	//4.Wait for EV6
	//EV6: ADDR=1, cleared by reading SR1 register followed by reading SR2.
	while(!I2C_GetFlagStatus(I2Cx, EV6));
 8000a76:	bf00      	nop
 8000a78:	2102      	movs	r1, #2
 8000a7a:	68f8      	ldr	r0, [r7, #12]
 8000a7c:	f7ff ff4e 	bl	800091c <I2C_GetFlagStatus>
 8000a80:	4603      	mov	r3, r0
 8000a82:	2b00      	cmp	r3, #0
 8000a84:	d0f8      	beq.n	8000a78 <MCAL_I2C_Master_RX+0x50>
	I2C_AcknowledgeConfig(I2Cx , ENABLE);
 8000a86:	2101      	movs	r1, #1
 8000a88:	68f8      	ldr	r0, [r7, #12]
 8000a8a:	f000 f921 	bl	8000cd0 <I2C_AcknowledgeConfig>

	if(dataLen)
 8000a8e:	683b      	ldr	r3, [r7, #0]
 8000a90:	2b00      	cmp	r3, #0
 8000a92:	d029      	beq.n	8000ae8 <MCAL_I2C_Master_RX+0xc0>
	{
		//read the data until len become zero
		for(i = dataLen ; i > 1 ; i--)
 8000a94:	683b      	ldr	r3, [r7, #0]
 8000a96:	617b      	str	r3, [r7, #20]
 8000a98:	e012      	b.n	8000ac0 <MCAL_I2C_Master_RX+0x98>
		{
			//wait until RXNE becomes 1
			while(!I2C_GetFlagStatus(I2Cx, EV7));
 8000a9a:	bf00      	nop
 8000a9c:	2106      	movs	r1, #6
 8000a9e:	68f8      	ldr	r0, [r7, #12]
 8000aa0:	f7ff ff3c 	bl	800091c <I2C_GetFlagStatus>
 8000aa4:	4603      	mov	r3, r0
 8000aa6:	2b00      	cmp	r3, #0
 8000aa8:	d0f8      	beq.n	8000a9c <MCAL_I2C_Master_RX+0x74>
			//read the data from register in to buffer
			*dataOut = I2Cx->DR;
 8000aaa:	68fb      	ldr	r3, [r7, #12]
 8000aac:	691b      	ldr	r3, [r3, #16]
 8000aae:	b2da      	uxtb	r2, r3
 8000ab0:	687b      	ldr	r3, [r7, #4]
 8000ab2:	701a      	strb	r2, [r3, #0]
			//increment the buffer address
			dataOut++;
 8000ab4:	687b      	ldr	r3, [r7, #4]
 8000ab6:	3301      	adds	r3, #1
 8000ab8:	607b      	str	r3, [r7, #4]
		for(i = dataLen ; i > 1 ; i--)
 8000aba:	697b      	ldr	r3, [r7, #20]
 8000abc:	3b01      	subs	r3, #1
 8000abe:	617b      	str	r3, [r7, #20]
 8000ac0:	697b      	ldr	r3, [r7, #20]
 8000ac2:	2b01      	cmp	r3, #1
 8000ac4:	dce9      	bgt.n	8000a9a <MCAL_I2C_Master_RX+0x72>
		}
		I2C_AcknowledgeConfig(I2Cx , DISABLE);
 8000ac6:	2100      	movs	r1, #0
 8000ac8:	68f8      	ldr	r0, [r7, #12]
 8000aca:	f000 f901 	bl	8000cd0 <I2C_AcknowledgeConfig>
		while(!I2C_GetFlagStatus(I2Cx, EV7));
 8000ace:	bf00      	nop
 8000ad0:	2106      	movs	r1, #6
 8000ad2:	68f8      	ldr	r0, [r7, #12]
 8000ad4:	f7ff ff22 	bl	800091c <I2C_GetFlagStatus>
 8000ad8:	4603      	mov	r3, r0
 8000ada:	2b00      	cmp	r3, #0
 8000adc:	d0f8      	beq.n	8000ad0 <MCAL_I2C_Master_RX+0xa8>
		*dataOut = I2Cx->DR;
 8000ade:	68fb      	ldr	r3, [r7, #12]
 8000ae0:	691b      	ldr	r3, [r3, #16]
 8000ae2:	b2da      	uxtb	r2, r3
 8000ae4:	687b      	ldr	r3, [r7, #4]
 8000ae6:	701a      	strb	r2, [r3, #0]
	}

	if(Stop != Without_Stop)
 8000ae8:	f897 3020 	ldrb.w	r3, [r7, #32]
 8000aec:	2b01      	cmp	r3, #1
 8000aee:	d003      	beq.n	8000af8 <MCAL_I2C_Master_RX+0xd0>
	{
		//send stop condition
		I2C_GenerateSTOP(I2Cx, ENABLE);
 8000af0:	2101      	movs	r1, #1
 8000af2:	68f8      	ldr	r0, [r7, #12]
 8000af4:	f7ff fef1 	bl	80008da <I2C_GenerateSTOP>
	}

	//re-enable ACKing
	if(Global_I2C_Config[index].I2C_ACK_Control == I2C_ACK_Enable)
 8000af8:	7cfa      	ldrb	r2, [r7, #19]
 8000afa:	490a      	ldr	r1, [pc, #40]	@ (8000b24 <MCAL_I2C_Master_RX+0xfc>)
 8000afc:	4613      	mov	r3, r2
 8000afe:	00db      	lsls	r3, r3, #3
 8000b00:	4413      	add	r3, r2
 8000b02:	009b      	lsls	r3, r3, #2
 8000b04:	440b      	add	r3, r1
 8000b06:	3318      	adds	r3, #24
 8000b08:	681b      	ldr	r3, [r3, #0]
 8000b0a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8000b0e:	d103      	bne.n	8000b18 <MCAL_I2C_Master_RX+0xf0>
	{
		I2C_AcknowledgeConfig(I2Cx , ENABLE);
 8000b10:	2101      	movs	r1, #1
 8000b12:	68f8      	ldr	r0, [r7, #12]
 8000b14:	f000 f8dc 	bl	8000cd0 <I2C_AcknowledgeConfig>
	}
}
 8000b18:	bf00      	nop
 8000b1a:	3718      	adds	r7, #24
 8000b1c:	46bd      	mov	sp, r7
 8000b1e:	bd80      	pop	{r7, pc}
 8000b20:	40005400 	.word	0x40005400
 8000b24:	20000058 	.word	0x20000058

08000b28 <I2C1_EV_IRQHandler>:
{
	return (uint8_t) I2Cx->DR;
}

void I2C1_EV_IRQHandler (void)
{
 8000b28:	b580      	push	{r7, lr}
 8000b2a:	b086      	sub	sp, #24
 8000b2c:	af00      	add	r7, sp, #0
	volatile uint32_t dummy_read = 0;
 8000b2e:	2300      	movs	r3, #0
 8000b30:	607b      	str	r3, [r7, #4]
	I2C_t* I2Cx = I2C1;
 8000b32:	4b2b      	ldr	r3, [pc, #172]	@ (8000be0 <I2C1_EV_IRQHandler+0xb8>)
 8000b34:	617b      	str	r3, [r7, #20]
	//Interrupt handling for both master and slave mode of a device
	uint32_t temp1, temp2, temp3;

	temp1 = I2Cx->CR2 & (I2C_CR2_ITEVTEN);
 8000b36:	697b      	ldr	r3, [r7, #20]
 8000b38:	685b      	ldr	r3, [r3, #4]
 8000b3a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8000b3e:	613b      	str	r3, [r7, #16]
	temp2 = I2Cx->CR2 & (I2C_CR2_ITBUFEN);
 8000b40:	697b      	ldr	r3, [r7, #20]
 8000b42:	685b      	ldr	r3, [r3, #4]
 8000b44:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8000b48:	60fb      	str	r3, [r7, #12]
	temp3 = I2Cx->SR1 & (I2C_SR1_STOPF);
 8000b4a:	697b      	ldr	r3, [r7, #20]
 8000b4c:	695b      	ldr	r3, [r3, #20]
 8000b4e:	f003 0310 	and.w	r3, r3, #16
 8000b52:	60bb      	str	r3, [r7, #8]

	//Handle for interrupt generated by STOPF event
	//Stop detection flag is applicable only slave mode
	if(temp1 && temp3)
 8000b54:	693b      	ldr	r3, [r7, #16]
 8000b56:	2b00      	cmp	r3, #0
 8000b58:	d00a      	beq.n	8000b70 <I2C1_EV_IRQHandler+0x48>
 8000b5a:	68bb      	ldr	r3, [r7, #8]
 8000b5c:	2b00      	cmp	r3, #0
 8000b5e:	d007      	beq.n	8000b70 <I2C1_EV_IRQHandler+0x48>
	{
		//STOP flag is set
		//Clear the STOPF (i.e 1) read SR1 2)Write to CR1
		I2Cx->CR1 |=0x0000;
 8000b60:	697b      	ldr	r3, [r7, #20]
 8000b62:	681a      	ldr	r2, [r3, #0]
 8000b64:	697b      	ldr	r3, [r7, #20]
 8000b66:	601a      	str	r2, [r3, #0]
		Slave_States(I2Cx, I2C_EV_STOP);
 8000b68:	2100      	movs	r1, #0
 8000b6a:	6978      	ldr	r0, [r7, #20]
 8000b6c:	f000 f840 	bl	8000bf0 <Slave_States>
	}
	//---------------------------------------
	temp3 = I2Cx->SR1 & (I2C_SR1_ADDR);
 8000b70:	697b      	ldr	r3, [r7, #20]
 8000b72:	695b      	ldr	r3, [r3, #20]
 8000b74:	f003 0302 	and.w	r3, r3, #2
 8000b78:	60bb      	str	r3, [r7, #8]
	//Handle for interrupt generated by ADDR event
	//When master mode : Address is sent
	//when slave mode : address matched with own address
	if(temp1 && temp3)
 8000b7a:	693b      	ldr	r3, [r7, #16]
 8000b7c:	2b00      	cmp	r3, #0
 8000b7e:	d012      	beq.n	8000ba6 <I2C1_EV_IRQHandler+0x7e>
 8000b80:	68bb      	ldr	r3, [r7, #8]
 8000b82:	2b00      	cmp	r3, #0
 8000b84:	d00f      	beq.n	8000ba6 <I2C1_EV_IRQHandler+0x7e>
	{
		//interrupt is generated because of ADDR event
		//check for device mode
		if(I2Cx->SR2 & (I2C_SR2_MSL))
 8000b86:	697b      	ldr	r3, [r7, #20]
 8000b88:	699b      	ldr	r3, [r3, #24]
 8000b8a:	f003 0301 	and.w	r3, r3, #1
 8000b8e:	2b00      	cmp	r3, #0
 8000b90:	d109      	bne.n	8000ba6 <I2C1_EV_IRQHandler+0x7e>
		}
		else
		{
			//slave mode
			//clear the ADDR flag (read SR1 , read SR2)
			dummy_read = I2Cx->SR1;
 8000b92:	697b      	ldr	r3, [r7, #20]
 8000b94:	695b      	ldr	r3, [r3, #20]
 8000b96:	607b      	str	r3, [r7, #4]
			dummy_read = I2Cx->SR2;
 8000b98:	697b      	ldr	r3, [r7, #20]
 8000b9a:	699b      	ldr	r3, [r3, #24]
 8000b9c:	607b      	str	r3, [r7, #4]
			Slave_States(I2Cx, I2C_EV_ADDR_Matched);
 8000b9e:	2102      	movs	r1, #2
 8000ba0:	6978      	ldr	r0, [r7, #20]
 8000ba2:	f000 f825 	bl	8000bf0 <Slave_States>
		}
	}
	//----------------------------------------------
	temp3 = I2Cx->SR1 & (I2C_SR1_TXE);
 8000ba6:	697b      	ldr	r3, [r7, #20]
 8000ba8:	695b      	ldr	r3, [r3, #20]
 8000baa:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8000bae:	60bb      	str	r3, [r7, #8]
	//handle for interrupt generated by TXE event
	if(temp1 && temp2 && temp3)
 8000bb0:	693b      	ldr	r3, [r7, #16]
 8000bb2:	2b00      	cmp	r3, #0
 8000bb4:	d00f      	beq.n	8000bd6 <I2C1_EV_IRQHandler+0xae>
 8000bb6:	68fb      	ldr	r3, [r7, #12]
 8000bb8:	2b00      	cmp	r3, #0
 8000bba:	d00c      	beq.n	8000bd6 <I2C1_EV_IRQHandler+0xae>
 8000bbc:	68bb      	ldr	r3, [r7, #8]
 8000bbe:	2b00      	cmp	r3, #0
 8000bc0:	d009      	beq.n	8000bd6 <I2C1_EV_IRQHandler+0xae>
	{
		//check for device mode
		if(I2Cx->SR2 & (I2C_SR2_MSL))
 8000bc2:	697b      	ldr	r3, [r7, #20]
 8000bc4:	699b      	ldr	r3, [r3, #24]
 8000bc6:	f003 0301 	and.w	r3, r3, #1
 8000bca:	2b00      	cmp	r3, #0
 8000bcc:	d103      	bne.n	8000bd6 <I2C1_EV_IRQHandler+0xae>
		{

		}
		else
		{
			Slave_States(I2Cx, I2C_EV_DATA_REQ);
 8000bce:	2103      	movs	r1, #3
 8000bd0:	6978      	ldr	r0, [r7, #20]
 8000bd2:	f000 f80d 	bl	8000bf0 <Slave_States>
		}
	}

}
 8000bd6:	bf00      	nop
 8000bd8:	3718      	adds	r7, #24
 8000bda:	46bd      	mov	sp, r7
 8000bdc:	bd80      	pop	{r7, pc}
 8000bde:	bf00      	nop
 8000be0:	40005400 	.word	0x40005400

08000be4 <I2C1_ER_IRQHandler>:
void I2C1_ER_IRQHandler (void)
{
 8000be4:	b480      	push	{r7}
 8000be6:	af00      	add	r7, sp, #0

}
 8000be8:	bf00      	nop
 8000bea:	46bd      	mov	sp, r7
 8000bec:	bc80      	pop	{r7}
 8000bee:	4770      	bx	lr

08000bf0 <Slave_States>:



void Slave_States(I2C_t* I2Cx, Slave_State state)
{
 8000bf0:	b580      	push	{r7, lr}
 8000bf2:	b084      	sub	sp, #16
 8000bf4:	af00      	add	r7, sp, #0
 8000bf6:	6078      	str	r0, [r7, #4]
 8000bf8:	460b      	mov	r3, r1
 8000bfa:	70fb      	strb	r3, [r7, #3]
	uint8_t index = I2Cx == I2C1 ? I2C1_INDEX :  I2C2_INDEX;
 8000bfc:	687b      	ldr	r3, [r7, #4]
 8000bfe:	4a32      	ldr	r2, [pc, #200]	@ (8000cc8 <Slave_States+0xd8>)
 8000c00:	4293      	cmp	r3, r2
 8000c02:	bf14      	ite	ne
 8000c04:	2301      	movne	r3, #1
 8000c06:	2300      	moveq	r3, #0
 8000c08:	b2db      	uxtb	r3, r3
 8000c0a:	73fb      	strb	r3, [r7, #15]

	switch(state)
 8000c0c:	78fb      	ldrb	r3, [r7, #3]
 8000c0e:	2b04      	cmp	r3, #4
 8000c10:	d856      	bhi.n	8000cc0 <Slave_States+0xd0>
 8000c12:	a201      	add	r2, pc, #4	@ (adr r2, 8000c18 <Slave_States+0x28>)
 8000c14:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000c18:	08000c33 	.word	0x08000c33
 8000c1c:	08000c2d 	.word	0x08000c2d
 8000c20:	08000c57 	.word	0x08000c57
 8000c24:	08000c6f 	.word	0x08000c6f
 8000c28:	08000c93 	.word	0x08000c93
	{
	case I2C_ERROR_AF:
		//make sure that the slave is really transmitter mode
		if(I2Cx->SR2 & (I2C_SR2_TRA))
 8000c2c:	687b      	ldr	r3, [r7, #4]
 8000c2e:	699b      	ldr	r3, [r3, #24]
		{
			//slave shouldn't send anything else
		}
		break;
 8000c30:	e046      	b.n	8000cc0 <Slave_States+0xd0>

	case I2C_EV_STOP:
		//make sure that the slave is really in transmitter mode
		if(I2Cx->SR2 & (I2C_SR2_TRA))
 8000c32:	687b      	ldr	r3, [r7, #4]
 8000c34:	699b      	ldr	r3, [r3, #24]
 8000c36:	f003 0304 	and.w	r3, r3, #4
 8000c3a:	2b00      	cmp	r3, #0
 8000c3c:	d03b      	beq.n	8000cb6 <Slave_States+0xc6>
		{
			Global_I2C_Config[index].P_Slave_Event_CallBack(I2C_EV_STOP);
 8000c3e:	7bfa      	ldrb	r2, [r7, #15]
 8000c40:	4922      	ldr	r1, [pc, #136]	@ (8000ccc <Slave_States+0xdc>)
 8000c42:	4613      	mov	r3, r2
 8000c44:	00db      	lsls	r3, r3, #3
 8000c46:	4413      	add	r3, r2
 8000c48:	009b      	lsls	r3, r3, #2
 8000c4a:	440b      	add	r3, r1
 8000c4c:	3320      	adds	r3, #32
 8000c4e:	681b      	ldr	r3, [r3, #0]
 8000c50:	2000      	movs	r0, #0
 8000c52:	4798      	blx	r3
		}
		break;
 8000c54:	e02f      	b.n	8000cb6 <Slave_States+0xc6>

	case I2C_EV_ADDR_Matched:
		//notify APP that the stop condition is sent by the master
		Global_I2C_Config[index].P_Slave_Event_CallBack(I2C_EV_ADDR_Matched);
 8000c56:	7bfa      	ldrb	r2, [r7, #15]
 8000c58:	491c      	ldr	r1, [pc, #112]	@ (8000ccc <Slave_States+0xdc>)
 8000c5a:	4613      	mov	r3, r2
 8000c5c:	00db      	lsls	r3, r3, #3
 8000c5e:	4413      	add	r3, r2
 8000c60:	009b      	lsls	r3, r3, #2
 8000c62:	440b      	add	r3, r1
 8000c64:	3320      	adds	r3, #32
 8000c66:	681b      	ldr	r3, [r3, #0]
 8000c68:	2002      	movs	r0, #2
 8000c6a:	4798      	blx	r3
		break;
 8000c6c:	e028      	b.n	8000cc0 <Slave_States+0xd0>

	case I2C_EV_DATA_REQ:
		//make sure that the slave is really in transmitter mode
		if(I2Cx->SR2 & (I2C_SR2_TRA))
 8000c6e:	687b      	ldr	r3, [r7, #4]
 8000c70:	699b      	ldr	r3, [r3, #24]
 8000c72:	f003 0304 	and.w	r3, r3, #4
 8000c76:	2b00      	cmp	r3, #0
 8000c78:	d01f      	beq.n	8000cba <Slave_States+0xca>
		{
			//the APP layer should send data (I2C_SlaveSendData) in this state
			Global_I2C_Config[index].P_Slave_Event_CallBack(I2C_EV_DATA_REQ);
 8000c7a:	7bfa      	ldrb	r2, [r7, #15]
 8000c7c:	4913      	ldr	r1, [pc, #76]	@ (8000ccc <Slave_States+0xdc>)
 8000c7e:	4613      	mov	r3, r2
 8000c80:	00db      	lsls	r3, r3, #3
 8000c82:	4413      	add	r3, r2
 8000c84:	009b      	lsls	r3, r3, #2
 8000c86:	440b      	add	r3, r1
 8000c88:	3320      	adds	r3, #32
 8000c8a:	681b      	ldr	r3, [r3, #0]
 8000c8c:	2003      	movs	r0, #3
 8000c8e:	4798      	blx	r3
		}
		break;
 8000c90:	e013      	b.n	8000cba <Slave_States+0xca>
	case I2C_EV_DATA_RCV:
		//make sure that the slave is really in receiver mode
		if(!(I2Cx->SR2 & (I2C_SR2_TRA)))
 8000c92:	687b      	ldr	r3, [r7, #4]
 8000c94:	699b      	ldr	r3, [r3, #24]
 8000c96:	f003 0304 	and.w	r3, r3, #4
 8000c9a:	2b00      	cmp	r3, #0
 8000c9c:	d10f      	bne.n	8000cbe <Slave_States+0xce>
		{
			//the APP layer should send data (I2C_SlaveSendData) in this state
			Global_I2C_Config[index].P_Slave_Event_CallBack(I2C_EV_DATA_RCV);
 8000c9e:	7bfa      	ldrb	r2, [r7, #15]
 8000ca0:	490a      	ldr	r1, [pc, #40]	@ (8000ccc <Slave_States+0xdc>)
 8000ca2:	4613      	mov	r3, r2
 8000ca4:	00db      	lsls	r3, r3, #3
 8000ca6:	4413      	add	r3, r2
 8000ca8:	009b      	lsls	r3, r3, #2
 8000caa:	440b      	add	r3, r1
 8000cac:	3320      	adds	r3, #32
 8000cae:	681b      	ldr	r3, [r3, #0]
 8000cb0:	2004      	movs	r0, #4
 8000cb2:	4798      	blx	r3
		}
		break;
 8000cb4:	e003      	b.n	8000cbe <Slave_States+0xce>
		break;
 8000cb6:	bf00      	nop
 8000cb8:	e002      	b.n	8000cc0 <Slave_States+0xd0>
		break;
 8000cba:	bf00      	nop
 8000cbc:	e000      	b.n	8000cc0 <Slave_States+0xd0>
		break;
 8000cbe:	bf00      	nop
	}

}
 8000cc0:	bf00      	nop
 8000cc2:	3710      	adds	r7, #16
 8000cc4:	46bd      	mov	sp, r7
 8000cc6:	bd80      	pop	{r7, pc}
 8000cc8:	40005400 	.word	0x40005400
 8000ccc:	20000058 	.word	0x20000058

08000cd0 <I2C_AcknowledgeConfig>:


void I2C_AcknowledgeConfig(I2C_t* I2Cx  , FunctionalState NewState)
{
 8000cd0:	b480      	push	{r7}
 8000cd2:	b083      	sub	sp, #12
 8000cd4:	af00      	add	r7, sp, #0
 8000cd6:	6078      	str	r0, [r7, #4]
 8000cd8:	460b      	mov	r3, r1
 8000cda:	70fb      	strb	r3, [r7, #3]
	if(NewState != DISABLE)
 8000cdc:	78fb      	ldrb	r3, [r7, #3]
 8000cde:	2b00      	cmp	r3, #0
 8000ce0:	d006      	beq.n	8000cf0 <I2C_AcknowledgeConfig+0x20>
	{
		//enable the acknowledgment
		I2Cx->CR1 |= I2C_CR1_ACK;
 8000ce2:	687b      	ldr	r3, [r7, #4]
 8000ce4:	681b      	ldr	r3, [r3, #0]
 8000ce6:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
 8000cea:	687b      	ldr	r3, [r7, #4]
 8000cec:	601a      	str	r2, [r3, #0]
	else
	{
		//disable the acknowledgment
		I2Cx->CR1 &= ~(I2C_CR1_ACK);
	}
}
 8000cee:	e005      	b.n	8000cfc <I2C_AcknowledgeConfig+0x2c>
		I2Cx->CR1 &= ~(I2C_CR1_ACK);
 8000cf0:	687b      	ldr	r3, [r7, #4]
 8000cf2:	681b      	ldr	r3, [r3, #0]
 8000cf4:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
 8000cf8:	687b      	ldr	r3, [r7, #4]
 8000cfa:	601a      	str	r2, [r3, #0]
}
 8000cfc:	bf00      	nop
 8000cfe:	370c      	adds	r7, #12
 8000d00:	46bd      	mov	sp, r7
 8000d02:	bc80      	pop	{r7}
 8000d04:	4770      	bx	lr
	...

08000d08 <MCAL_RCC_GetSYS_CLKFreq>:
const uint8_t AHBprescTable[16U] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};



uint32_t MCAL_RCC_GetSYS_CLKFreq(void)
{
 8000d08:	b480      	push	{r7}
 8000d0a:	af00      	add	r7, sp, #0
	switch((RCC->CFGR >> 2) & 0b11)
 8000d0c:	4b0c      	ldr	r3, [pc, #48]	@ (8000d40 <MCAL_RCC_GetSYS_CLKFreq+0x38>)
 8000d0e:	685b      	ldr	r3, [r3, #4]
 8000d10:	089b      	lsrs	r3, r3, #2
 8000d12:	f003 0303 	and.w	r3, r3, #3
 8000d16:	2b02      	cmp	r3, #2
 8000d18:	d00a      	beq.n	8000d30 <MCAL_RCC_GetSYS_CLKFreq+0x28>
 8000d1a:	2b02      	cmp	r3, #2
 8000d1c:	d80a      	bhi.n	8000d34 <MCAL_RCC_GetSYS_CLKFreq+0x2c>
 8000d1e:	2b00      	cmp	r3, #0
 8000d20:	d002      	beq.n	8000d28 <MCAL_RCC_GetSYS_CLKFreq+0x20>
 8000d22:	2b01      	cmp	r3, #1
 8000d24:	d002      	beq.n	8000d2c <MCAL_RCC_GetSYS_CLKFreq+0x24>
 8000d26:	e005      	b.n	8000d34 <MCAL_RCC_GetSYS_CLKFreq+0x2c>
	{
	case 0:
		return HSI_RC_Clk;
 8000d28:	4b06      	ldr	r3, [pc, #24]	@ (8000d44 <MCAL_RCC_GetSYS_CLKFreq+0x3c>)
 8000d2a:	e004      	b.n	8000d36 <MCAL_RCC_GetSYS_CLKFreq+0x2e>
		break;
	case 1:
		//to do need to calculate  it //HSE User Should Specify it
		return HSE_Clock;
 8000d2c:	4b06      	ldr	r3, [pc, #24]	@ (8000d48 <MCAL_RCC_GetSYS_CLKFreq+0x40>)
 8000d2e:	e002      	b.n	8000d36 <MCAL_RCC_GetSYS_CLKFreq+0x2e>
		break;
	case 2:
		//to do need to calculate  it PLLCLK and PLLMUL & PLL Source MUX
		return 16000000;
 8000d30:	4b05      	ldr	r3, [pc, #20]	@ (8000d48 <MCAL_RCC_GetSYS_CLKFreq+0x40>)
 8000d32:	e000      	b.n	8000d36 <MCAL_RCC_GetSYS_CLKFreq+0x2e>
		break;
	}
	return 0;
 8000d34:	2300      	movs	r3, #0
}
 8000d36:	4618      	mov	r0, r3
 8000d38:	46bd      	mov	sp, r7
 8000d3a:	bc80      	pop	{r7}
 8000d3c:	4770      	bx	lr
 8000d3e:	bf00      	nop
 8000d40:	40021000 	.word	0x40021000
 8000d44:	007a1200 	.word	0x007a1200
 8000d48:	00f42400 	.word	0x00f42400

08000d4c <MCAL_RCC_GetHCLKFreq>:

uint32_t MCAL_RCC_GetHCLKFreq(void)
{
 8000d4c:	b580      	push	{r7, lr}
 8000d4e:	af00      	add	r7, sp, #0
	// Bits 7:4HPRE: AHB prescaler
	return (MCAL_RCC_GetSYS_CLKFreq() >> AHBprescTable[(RCC->CFGR >> 4) & 0xf]);
 8000d50:	f7ff ffda 	bl	8000d08 <MCAL_RCC_GetSYS_CLKFreq>
 8000d54:	4602      	mov	r2, r0
 8000d56:	4b05      	ldr	r3, [pc, #20]	@ (8000d6c <MCAL_RCC_GetHCLKFreq+0x20>)
 8000d58:	685b      	ldr	r3, [r3, #4]
 8000d5a:	091b      	lsrs	r3, r3, #4
 8000d5c:	f003 030f 	and.w	r3, r3, #15
 8000d60:	4903      	ldr	r1, [pc, #12]	@ (8000d70 <MCAL_RCC_GetHCLKFreq+0x24>)
 8000d62:	5ccb      	ldrb	r3, [r1, r3]
 8000d64:	fa22 f303 	lsr.w	r3, r2, r3
}
 8000d68:	4618      	mov	r0, r3
 8000d6a:	bd80      	pop	{r7, pc}
 8000d6c:	40021000 	.word	0x40021000
 8000d70:	080012bc 	.word	0x080012bc

08000d74 <MCAL_RCC_GetPCLK1Freq>:

uint32_t MCAL_RCC_GetPCLK1Freq(void)
{
 8000d74:	b580      	push	{r7, lr}
 8000d76:	af00      	add	r7, sp, #0
	return (MCAL_RCC_GetHCLKFreq() >> APBprescTable[(RCC->CFGR >> 8) & 0b111]);
 8000d78:	f7ff ffe8 	bl	8000d4c <MCAL_RCC_GetHCLKFreq>
 8000d7c:	4602      	mov	r2, r0
 8000d7e:	4b05      	ldr	r3, [pc, #20]	@ (8000d94 <MCAL_RCC_GetPCLK1Freq+0x20>)
 8000d80:	685b      	ldr	r3, [r3, #4]
 8000d82:	0a1b      	lsrs	r3, r3, #8
 8000d84:	f003 0307 	and.w	r3, r3, #7
 8000d88:	4903      	ldr	r1, [pc, #12]	@ (8000d98 <MCAL_RCC_GetPCLK1Freq+0x24>)
 8000d8a:	5ccb      	ldrb	r3, [r1, r3]
 8000d8c:	fa22 f303 	lsr.w	r3, r2, r3
}
 8000d90:	4618      	mov	r0, r3
 8000d92:	bd80      	pop	{r7, pc}
 8000d94:	40021000 	.word	0x40021000
 8000d98:	080012b4 	.word	0x080012b4

08000d9c <SPI1_IRQHandler>:
 * =======================================================================================
 */


void SPI1_IRQHandler(void)
{
 8000d9c:	b580      	push	{r7, lr}
 8000d9e:	b082      	sub	sp, #8
 8000da0:	af00      	add	r7, sp, #0
	struct S_IRQ_SRC IRQ_SRC;
	IRQ_SRC.TXE = ((SPI1->SR & (1<<1)) >> 1);
 8000da2:	4b13      	ldr	r3, [pc, #76]	@ (8000df0 <SPI1_IRQHandler+0x54>)
 8000da4:	689b      	ldr	r3, [r3, #8]
 8000da6:	085b      	lsrs	r3, r3, #1
 8000da8:	f003 0301 	and.w	r3, r3, #1
 8000dac:	b2da      	uxtb	r2, r3
 8000dae:	793b      	ldrb	r3, [r7, #4]
 8000db0:	f362 0300 	bfi	r3, r2, #0, #1
 8000db4:	713b      	strb	r3, [r7, #4]
	IRQ_SRC.RXNE = ((SPI1->SR & (1<<0)) >> 0);
 8000db6:	4b0e      	ldr	r3, [pc, #56]	@ (8000df0 <SPI1_IRQHandler+0x54>)
 8000db8:	689b      	ldr	r3, [r3, #8]
 8000dba:	f003 0301 	and.w	r3, r3, #1
 8000dbe:	b2da      	uxtb	r2, r3
 8000dc0:	793b      	ldrb	r3, [r7, #4]
 8000dc2:	f362 0341 	bfi	r3, r2, #1, #1
 8000dc6:	713b      	strb	r3, [r7, #4]
	IRQ_SRC.ERRI = ((SPI1->SR & (1<<4)) >> 4);
 8000dc8:	4b09      	ldr	r3, [pc, #36]	@ (8000df0 <SPI1_IRQHandler+0x54>)
 8000dca:	689b      	ldr	r3, [r3, #8]
 8000dcc:	091b      	lsrs	r3, r3, #4
 8000dce:	f003 0301 	and.w	r3, r3, #1
 8000dd2:	b2da      	uxtb	r2, r3
 8000dd4:	793b      	ldrb	r3, [r7, #4]
 8000dd6:	f362 0382 	bfi	r3, r2, #2, #1
 8000dda:	713b      	strb	r3, [r7, #4]
	Global_SPI_Config[SPI1_Index]->P_IRQ_CallBack(IRQ_SRC);
 8000ddc:	4b05      	ldr	r3, [pc, #20]	@ (8000df4 <SPI1_IRQHandler+0x58>)
 8000dde:	681b      	ldr	r3, [r3, #0]
 8000de0:	695b      	ldr	r3, [r3, #20]
 8000de2:	6878      	ldr	r0, [r7, #4]
 8000de4:	4798      	blx	r3
}
 8000de6:	bf00      	nop
 8000de8:	3708      	adds	r7, #8
 8000dea:	46bd      	mov	sp, r7
 8000dec:	bd80      	pop	{r7, pc}
 8000dee:	bf00      	nop
 8000df0:	40013000 	.word	0x40013000
 8000df4:	200000a0 	.word	0x200000a0

08000df8 <SPI2_IRQHandler>:

void SPI2_IRQHandler(void)
{
 8000df8:	b580      	push	{r7, lr}
 8000dfa:	b082      	sub	sp, #8
 8000dfc:	af00      	add	r7, sp, #0
	struct S_IRQ_SRC IRQ_SRC;
	IRQ_SRC.TXE = ((SPI2->SR & (1<<1)) >> 1);
 8000dfe:	4b13      	ldr	r3, [pc, #76]	@ (8000e4c <SPI2_IRQHandler+0x54>)
 8000e00:	689b      	ldr	r3, [r3, #8]
 8000e02:	085b      	lsrs	r3, r3, #1
 8000e04:	f003 0301 	and.w	r3, r3, #1
 8000e08:	b2da      	uxtb	r2, r3
 8000e0a:	793b      	ldrb	r3, [r7, #4]
 8000e0c:	f362 0300 	bfi	r3, r2, #0, #1
 8000e10:	713b      	strb	r3, [r7, #4]
	IRQ_SRC.RXNE = ((SPI2->SR & (1<<0)) >> 0);
 8000e12:	4b0e      	ldr	r3, [pc, #56]	@ (8000e4c <SPI2_IRQHandler+0x54>)
 8000e14:	689b      	ldr	r3, [r3, #8]
 8000e16:	f003 0301 	and.w	r3, r3, #1
 8000e1a:	b2da      	uxtb	r2, r3
 8000e1c:	793b      	ldrb	r3, [r7, #4]
 8000e1e:	f362 0341 	bfi	r3, r2, #1, #1
 8000e22:	713b      	strb	r3, [r7, #4]
	IRQ_SRC.ERRI = ((SPI2->SR & (1<<4)) >> 4);
 8000e24:	4b09      	ldr	r3, [pc, #36]	@ (8000e4c <SPI2_IRQHandler+0x54>)
 8000e26:	689b      	ldr	r3, [r3, #8]
 8000e28:	091b      	lsrs	r3, r3, #4
 8000e2a:	f003 0301 	and.w	r3, r3, #1
 8000e2e:	b2da      	uxtb	r2, r3
 8000e30:	793b      	ldrb	r3, [r7, #4]
 8000e32:	f362 0382 	bfi	r3, r2, #2, #1
 8000e36:	713b      	strb	r3, [r7, #4]
	Global_SPI_Config[SPI2_Index]->P_IRQ_CallBack(IRQ_SRC);
 8000e38:	4b05      	ldr	r3, [pc, #20]	@ (8000e50 <SPI2_IRQHandler+0x58>)
 8000e3a:	685b      	ldr	r3, [r3, #4]
 8000e3c:	695b      	ldr	r3, [r3, #20]
 8000e3e:	6878      	ldr	r0, [r7, #4]
 8000e40:	4798      	blx	r3
}
 8000e42:	bf00      	nop
 8000e44:	3708      	adds	r7, #8
 8000e46:	46bd      	mov	sp, r7
 8000e48:	bd80      	pop	{r7, pc}
 8000e4a:	bf00      	nop
 8000e4c:	40003800 	.word	0x40003800
 8000e50:	200000a0 	.word	0x200000a0

08000e54 <USART1_IRQHandler>:
 * 						ISR Functions
 * =======================================================================================
 */

void USART1_IRQHandler(void)
{
 8000e54:	b580      	push	{r7, lr}
 8000e56:	af00      	add	r7, sp, #0
	//RXNE interrupt
	if(((USART1->SR) & (1<<5)) && ((USART1->CR1) & (1<<5)) )
 8000e58:	4b08      	ldr	r3, [pc, #32]	@ (8000e7c <USART1_IRQHandler+0x28>)
 8000e5a:	681b      	ldr	r3, [r3, #0]
 8000e5c:	f003 0320 	and.w	r3, r3, #32
 8000e60:	2b00      	cmp	r3, #0
 8000e62:	d009      	beq.n	8000e78 <USART1_IRQHandler+0x24>
 8000e64:	4b05      	ldr	r3, [pc, #20]	@ (8000e7c <USART1_IRQHandler+0x28>)
 8000e66:	68db      	ldr	r3, [r3, #12]
 8000e68:	f003 0320 	and.w	r3, r3, #32
 8000e6c:	2b00      	cmp	r3, #0
 8000e6e:	d003      	beq.n	8000e78 <USART1_IRQHandler+0x24>
	{
		Global_UART1_Config->P_IRQ_CallBack();
 8000e70:	4b03      	ldr	r3, [pc, #12]	@ (8000e80 <USART1_IRQHandler+0x2c>)
 8000e72:	681b      	ldr	r3, [r3, #0]
 8000e74:	691b      	ldr	r3, [r3, #16]
 8000e76:	4798      	blx	r3
	}
}
 8000e78:	bf00      	nop
 8000e7a:	bd80      	pop	{r7, pc}
 8000e7c:	40013800 	.word	0x40013800
 8000e80:	200000a8 	.word	0x200000a8

08000e84 <USART2_IRQHandler>:

void USART2_IRQHandler(void)
{
 8000e84:	b580      	push	{r7, lr}
 8000e86:	af00      	add	r7, sp, #0
	//RXNE interrupt
	if(((USART2->SR) & (1<<5)) && ((USART2->CR1) & (1<<5)) )
 8000e88:	4b08      	ldr	r3, [pc, #32]	@ (8000eac <USART2_IRQHandler+0x28>)
 8000e8a:	681b      	ldr	r3, [r3, #0]
 8000e8c:	f003 0320 	and.w	r3, r3, #32
 8000e90:	2b00      	cmp	r3, #0
 8000e92:	d009      	beq.n	8000ea8 <USART2_IRQHandler+0x24>
 8000e94:	4b05      	ldr	r3, [pc, #20]	@ (8000eac <USART2_IRQHandler+0x28>)
 8000e96:	68db      	ldr	r3, [r3, #12]
 8000e98:	f003 0320 	and.w	r3, r3, #32
 8000e9c:	2b00      	cmp	r3, #0
 8000e9e:	d003      	beq.n	8000ea8 <USART2_IRQHandler+0x24>
	{
		Global_UART2_Config->P_IRQ_CallBack();
 8000ea0:	4b03      	ldr	r3, [pc, #12]	@ (8000eb0 <USART2_IRQHandler+0x2c>)
 8000ea2:	681b      	ldr	r3, [r3, #0]
 8000ea4:	691b      	ldr	r3, [r3, #16]
 8000ea6:	4798      	blx	r3
	}
}
 8000ea8:	bf00      	nop
 8000eaa:	bd80      	pop	{r7, pc}
 8000eac:	40004400 	.word	0x40004400
 8000eb0:	200000ac 	.word	0x200000ac

08000eb4 <USART3_IRQHandler>:

void USART3_IRQHandler(void)
{
 8000eb4:	b580      	push	{r7, lr}
 8000eb6:	af00      	add	r7, sp, #0
	//RXNE interrupt
	if(((USART3->SR) & (1<<5)) && ((USART3->CR1) & (1<<5)) )
 8000eb8:	4b08      	ldr	r3, [pc, #32]	@ (8000edc <USART3_IRQHandler+0x28>)
 8000eba:	681b      	ldr	r3, [r3, #0]
 8000ebc:	f003 0320 	and.w	r3, r3, #32
 8000ec0:	2b00      	cmp	r3, #0
 8000ec2:	d009      	beq.n	8000ed8 <USART3_IRQHandler+0x24>
 8000ec4:	4b05      	ldr	r3, [pc, #20]	@ (8000edc <USART3_IRQHandler+0x28>)
 8000ec6:	68db      	ldr	r3, [r3, #12]
 8000ec8:	f003 0320 	and.w	r3, r3, #32
 8000ecc:	2b00      	cmp	r3, #0
 8000ece:	d003      	beq.n	8000ed8 <USART3_IRQHandler+0x24>
	{
		Global_UART3_Config->P_IRQ_CallBack();
 8000ed0:	4b03      	ldr	r3, [pc, #12]	@ (8000ee0 <USART3_IRQHandler+0x2c>)
 8000ed2:	681b      	ldr	r3, [r3, #0]
 8000ed4:	691b      	ldr	r3, [r3, #16]
 8000ed6:	4798      	blx	r3
	}
}
 8000ed8:	bf00      	nop
 8000eda:	bd80      	pop	{r7, pc}
 8000edc:	40004800 	.word	0x40004800
 8000ee0:	200000b0 	.word	0x200000b0

08000ee4 <Get_PinPostion>:
#include "Stm32_F103C6_gpio_driver.h"

uint8_t Get_PinPostion(uint16_t PinNumber)
{
 8000ee4:	b480      	push	{r7}
 8000ee6:	b083      	sub	sp, #12
 8000ee8:	af00      	add	r7, sp, #0
 8000eea:	4603      	mov	r3, r0
 8000eec:	80fb      	strh	r3, [r7, #6]
	switch(PinNumber)
 8000eee:	88fb      	ldrh	r3, [r7, #6]
 8000ef0:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8000ef4:	f000 808f 	beq.w	8001016 <Get_PinPostion+0x132>
 8000ef8:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8000efc:	f300 808d 	bgt.w	800101a <Get_PinPostion+0x136>
 8000f00:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8000f04:	f000 8085 	beq.w	8001012 <Get_PinPostion+0x12e>
 8000f08:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8000f0c:	f300 8085 	bgt.w	800101a <Get_PinPostion+0x136>
 8000f10:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8000f14:	d07b      	beq.n	800100e <Get_PinPostion+0x12a>
 8000f16:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8000f1a:	dc7e      	bgt.n	800101a <Get_PinPostion+0x136>
 8000f1c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8000f20:	d073      	beq.n	800100a <Get_PinPostion+0x126>
 8000f22:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8000f26:	dc78      	bgt.n	800101a <Get_PinPostion+0x136>
 8000f28:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8000f2c:	d06b      	beq.n	8001006 <Get_PinPostion+0x122>
 8000f2e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8000f32:	dc72      	bgt.n	800101a <Get_PinPostion+0x136>
 8000f34:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8000f38:	d063      	beq.n	8001002 <Get_PinPostion+0x11e>
 8000f3a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8000f3e:	dc6c      	bgt.n	800101a <Get_PinPostion+0x136>
 8000f40:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8000f44:	d05b      	beq.n	8000ffe <Get_PinPostion+0x11a>
 8000f46:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8000f4a:	dc66      	bgt.n	800101a <Get_PinPostion+0x136>
 8000f4c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8000f50:	d053      	beq.n	8000ffa <Get_PinPostion+0x116>
 8000f52:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8000f56:	dc60      	bgt.n	800101a <Get_PinPostion+0x136>
 8000f58:	2b80      	cmp	r3, #128	@ 0x80
 8000f5a:	d05c      	beq.n	8001016 <Get_PinPostion+0x132>
 8000f5c:	2b80      	cmp	r3, #128	@ 0x80
 8000f5e:	dc5c      	bgt.n	800101a <Get_PinPostion+0x136>
 8000f60:	2b20      	cmp	r3, #32
 8000f62:	dc47      	bgt.n	8000ff4 <Get_PinPostion+0x110>
 8000f64:	2b00      	cmp	r3, #0
 8000f66:	dd58      	ble.n	800101a <Get_PinPostion+0x136>
 8000f68:	3b01      	subs	r3, #1
 8000f6a:	2b1f      	cmp	r3, #31
 8000f6c:	d855      	bhi.n	800101a <Get_PinPostion+0x136>
 8000f6e:	a201      	add	r2, pc, #4	@ (adr r2, 8000f74 <Get_PinPostion+0x90>)
 8000f70:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000f74:	08000ffb 	.word	0x08000ffb
 8000f78:	08000fff 	.word	0x08000fff
 8000f7c:	0800101b 	.word	0x0800101b
 8000f80:	08001003 	.word	0x08001003
 8000f84:	0800101b 	.word	0x0800101b
 8000f88:	0800101b 	.word	0x0800101b
 8000f8c:	0800101b 	.word	0x0800101b
 8000f90:	08001007 	.word	0x08001007
 8000f94:	0800101b 	.word	0x0800101b
 8000f98:	0800101b 	.word	0x0800101b
 8000f9c:	0800101b 	.word	0x0800101b
 8000fa0:	0800101b 	.word	0x0800101b
 8000fa4:	0800101b 	.word	0x0800101b
 8000fa8:	0800101b 	.word	0x0800101b
 8000fac:	0800101b 	.word	0x0800101b
 8000fb0:	0800100b 	.word	0x0800100b
 8000fb4:	0800101b 	.word	0x0800101b
 8000fb8:	0800101b 	.word	0x0800101b
 8000fbc:	0800101b 	.word	0x0800101b
 8000fc0:	0800101b 	.word	0x0800101b
 8000fc4:	0800101b 	.word	0x0800101b
 8000fc8:	0800101b 	.word	0x0800101b
 8000fcc:	0800101b 	.word	0x0800101b
 8000fd0:	0800101b 	.word	0x0800101b
 8000fd4:	0800101b 	.word	0x0800101b
 8000fd8:	0800101b 	.word	0x0800101b
 8000fdc:	0800101b 	.word	0x0800101b
 8000fe0:	0800101b 	.word	0x0800101b
 8000fe4:	0800101b 	.word	0x0800101b
 8000fe8:	0800101b 	.word	0x0800101b
 8000fec:	0800101b 	.word	0x0800101b
 8000ff0:	0800100f 	.word	0x0800100f
 8000ff4:	2b40      	cmp	r3, #64	@ 0x40
 8000ff6:	d00c      	beq.n	8001012 <Get_PinPostion+0x12e>
 8000ff8:	e00f      	b.n	800101a <Get_PinPostion+0x136>
	{
	case GPIO_PIN_0:
	case GPIO_PIN_8:
		return 0;
 8000ffa:	2300      	movs	r3, #0
 8000ffc:	e00e      	b.n	800101c <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_1:
	case GPIO_PIN_9:
		return 4;
 8000ffe:	2304      	movs	r3, #4
 8001000:	e00c      	b.n	800101c <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_2:
	case GPIO_PIN_10:
		return 8;
 8001002:	2308      	movs	r3, #8
 8001004:	e00a      	b.n	800101c <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_3:
	case GPIO_PIN_11:
		return 12;
 8001006:	230c      	movs	r3, #12
 8001008:	e008      	b.n	800101c <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_4:
	case GPIO_PIN_12:
		return 16;
 800100a:	2310      	movs	r3, #16
 800100c:	e006      	b.n	800101c <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_5:
	case GPIO_PIN_13:
		return 20;
 800100e:	2314      	movs	r3, #20
 8001010:	e004      	b.n	800101c <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_6:
	case GPIO_PIN_14:
		return 24;
 8001012:	2318      	movs	r3, #24
 8001014:	e002      	b.n	800101c <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_7:
	case GPIO_PIN_15:
		return 28;
 8001016:	231c      	movs	r3, #28
 8001018:	e000      	b.n	800101c <Get_PinPostion+0x138>
		break;
	}
	return 0;
 800101a:	2300      	movs	r3, #0
}
 800101c:	4618      	mov	r0, r3
 800101e:	370c      	adds	r7, #12
 8001020:	46bd      	mov	sp, r7
 8001022:	bc80      	pop	{r7}
 8001024:	4770      	bx	lr
 8001026:	bf00      	nop

08001028 <MCAL_GPIO_Init>:
 * 							 the configuration information for the specified GPIO PIN
 * @retval 		-none
 * Note			-none
================================================================**/
void MCAL_GPIO_Init(GPIO_t *GPIOx,GPIO_Config_t *pin_config)
{
 8001028:	b590      	push	{r4, r7, lr}
 800102a:	b085      	sub	sp, #20
 800102c:	af00      	add	r7, sp, #0
 800102e:	6078      	str	r0, [r7, #4]
 8001030:	6039      	str	r1, [r7, #0]
	// Port configuration register high (GPIOx_CRH) configure PINs from 0 >> 7
	// Port configuration register high (GPIOx_CRH) configure PINs from 8 >> 15
	volatile uint32_t *confg_reg = NULL;
 8001032:	2300      	movs	r3, #0
 8001034:	60bb      	str	r3, [r7, #8]
	uint8_t PinConfig = 0;
 8001036:	2300      	movs	r3, #0
 8001038:	73fb      	strb	r3, [r7, #15]
	//see if it's CRL or CRH
	confg_reg = (pin_config->GPIO_PinNumber < GPIO_PIN_8)? &GPIOx->CRL: &GPIOx->CRH ;
 800103a:	683b      	ldr	r3, [r7, #0]
 800103c:	881b      	ldrh	r3, [r3, #0]
 800103e:	2bff      	cmp	r3, #255	@ 0xff
 8001040:	d801      	bhi.n	8001046 <MCAL_GPIO_Init+0x1e>
 8001042:	687b      	ldr	r3, [r7, #4]
 8001044:	e001      	b.n	800104a <MCAL_GPIO_Init+0x22>
 8001046:	687b      	ldr	r3, [r7, #4]
 8001048:	3304      	adds	r3, #4
 800104a:	60bb      	str	r3, [r7, #8]
	//Reset CNF and MODE
	*confg_reg &= ~(0xf<<Get_PinPostion(pin_config->GPIO_PinNumber));//* because we will write value
 800104c:	683b      	ldr	r3, [r7, #0]
 800104e:	881b      	ldrh	r3, [r3, #0]
 8001050:	4618      	mov	r0, r3
 8001052:	f7ff ff47 	bl	8000ee4 <Get_PinPostion>
 8001056:	4603      	mov	r3, r0
 8001058:	461a      	mov	r2, r3
 800105a:	230f      	movs	r3, #15
 800105c:	4093      	lsls	r3, r2
 800105e:	43da      	mvns	r2, r3
 8001060:	68bb      	ldr	r3, [r7, #8]
 8001062:	681b      	ldr	r3, [r3, #0]
 8001064:	401a      	ands	r2, r3
 8001066:	68bb      	ldr	r3, [r7, #8]
 8001068:	601a      	str	r2, [r3, #0]

	//if it's output
	if((pin_config->GPIO_PinMode == GPIO_MODE_OUTPUT_PP)||(pin_config->GPIO_PinMode == GPIO_MODE_OUTPUT_OD)||(pin_config->GPIO_PinMode == GPIO_MODE_OUTPUT_AF_PP)||(pin_config->GPIO_PinMode == GPIO_MODE_OUTPUT_AF_OD))
 800106a:	683b      	ldr	r3, [r7, #0]
 800106c:	885b      	ldrh	r3, [r3, #2]
 800106e:	2b04      	cmp	r3, #4
 8001070:	d00b      	beq.n	800108a <MCAL_GPIO_Init+0x62>
 8001072:	683b      	ldr	r3, [r7, #0]
 8001074:	885b      	ldrh	r3, [r3, #2]
 8001076:	2b05      	cmp	r3, #5
 8001078:	d007      	beq.n	800108a <MCAL_GPIO_Init+0x62>
 800107a:	683b      	ldr	r3, [r7, #0]
 800107c:	885b      	ldrh	r3, [r3, #2]
 800107e:	2b06      	cmp	r3, #6
 8001080:	d003      	beq.n	800108a <MCAL_GPIO_Init+0x62>
 8001082:	683b      	ldr	r3, [r7, #0]
 8001084:	885b      	ldrh	r3, [r3, #2]
 8001086:	2b07      	cmp	r3, #7
 8001088:	d10f      	bne.n	80010aa <MCAL_GPIO_Init+0x82>
		 * 00: General purpose output push-pull
		 * 01: General purpose output Open-drain
		 * 10: Alternate function output Push-pull
		 * 11: Alternate function output Open-drain
		 */
		PinConfig = ((((pin_config->GPIO_PinMode - 4) <<2)|(pin_config->GPIO_PinSpeed))&0xf);
 800108a:	683b      	ldr	r3, [r7, #0]
 800108c:	885b      	ldrh	r3, [r3, #2]
 800108e:	3b04      	subs	r3, #4
 8001090:	b25b      	sxtb	r3, r3
 8001092:	009b      	lsls	r3, r3, #2
 8001094:	b25a      	sxtb	r2, r3
 8001096:	683b      	ldr	r3, [r7, #0]
 8001098:	889b      	ldrh	r3, [r3, #4]
 800109a:	b25b      	sxtb	r3, r3
 800109c:	4313      	orrs	r3, r2
 800109e:	b25b      	sxtb	r3, r3
 80010a0:	b2db      	uxtb	r3, r3
 80010a2:	f003 030f 	and.w	r3, r3, #15
 80010a6:	73fb      	strb	r3, [r7, #15]
 80010a8:	e02d      	b.n	8001106 <MCAL_GPIO_Init+0xde>
		 * 01: Floating input
		 * 01: Alternative input
		 * 11: Input with PU or PD
		 * //the diff between PU & PD :=> PU: ODR --> 1  PD: ODR --> 0
		 */
		if((pin_config->GPIO_PinMode == GPIO_MODE_ANALOG)||(pin_config->GPIO_PinMode == GPIO_MODE_INPUT_FLO))
 80010aa:	683b      	ldr	r3, [r7, #0]
 80010ac:	885b      	ldrh	r3, [r3, #2]
 80010ae:	2b00      	cmp	r3, #0
 80010b0:	d003      	beq.n	80010ba <MCAL_GPIO_Init+0x92>
 80010b2:	683b      	ldr	r3, [r7, #0]
 80010b4:	885b      	ldrh	r3, [r3, #2]
 80010b6:	2b01      	cmp	r3, #1
 80010b8:	d108      	bne.n	80010cc <MCAL_GPIO_Init+0xa4>
		{
			PinConfig = (((pin_config->GPIO_PinMode << 2))&0xf);
 80010ba:	683b      	ldr	r3, [r7, #0]
 80010bc:	885b      	ldrh	r3, [r3, #2]
 80010be:	b2db      	uxtb	r3, r3
 80010c0:	009b      	lsls	r3, r3, #2
 80010c2:	b2db      	uxtb	r3, r3
 80010c4:	f003 030f 	and.w	r3, r3, #15
 80010c8:	73fb      	strb	r3, [r7, #15]
 80010ca:	e01c      	b.n	8001106 <MCAL_GPIO_Init+0xde>
		}
		else if(pin_config->GPIO_PinMode == GPIO_MODE_INPUT_AF)
 80010cc:	683b      	ldr	r3, [r7, #0]
 80010ce:	885b      	ldrh	r3, [r3, #2]
 80010d0:	2b08      	cmp	r3, #8
 80010d2:	d102      	bne.n	80010da <MCAL_GPIO_Init+0xb2>
		{
			PinConfig = (((GPIO_MODE_INPUT_FLO << 2))&0xf);
 80010d4:	2304      	movs	r3, #4
 80010d6:	73fb      	strb	r3, [r7, #15]
 80010d8:	e015      	b.n	8001106 <MCAL_GPIO_Init+0xde>
		}
		else
		{
			PinConfig = (((GPIO_MODE_INPUT_PU << 2))&0xf);
 80010da:	2308      	movs	r3, #8
 80010dc:	73fb      	strb	r3, [r7, #15]
			if(pin_config->GPIO_PinMode == GPIO_MODE_INPUT_PU)
 80010de:	683b      	ldr	r3, [r7, #0]
 80010e0:	885b      	ldrh	r3, [r3, #2]
 80010e2:	2b02      	cmp	r3, #2
 80010e4:	d107      	bne.n	80010f6 <MCAL_GPIO_Init+0xce>
				GPIOx->ODR |= pin_config->GPIO_PinNumber;
 80010e6:	687b      	ldr	r3, [r7, #4]
 80010e8:	68db      	ldr	r3, [r3, #12]
 80010ea:	683a      	ldr	r2, [r7, #0]
 80010ec:	8812      	ldrh	r2, [r2, #0]
 80010ee:	431a      	orrs	r2, r3
 80010f0:	687b      	ldr	r3, [r7, #4]
 80010f2:	60da      	str	r2, [r3, #12]
 80010f4:	e007      	b.n	8001106 <MCAL_GPIO_Init+0xde>
			else
				GPIOx->ODR &= ~pin_config->GPIO_PinNumber;
 80010f6:	687b      	ldr	r3, [r7, #4]
 80010f8:	68db      	ldr	r3, [r3, #12]
 80010fa:	683a      	ldr	r2, [r7, #0]
 80010fc:	8812      	ldrh	r2, [r2, #0]
 80010fe:	43d2      	mvns	r2, r2
 8001100:	401a      	ands	r2, r3
 8001102:	687b      	ldr	r3, [r7, #4]
 8001104:	60da      	str	r2, [r3, #12]
		}
	}
	*confg_reg |= (PinConfig<<Get_PinPostion(pin_config->GPIO_PinNumber));
 8001106:	7bfc      	ldrb	r4, [r7, #15]
 8001108:	683b      	ldr	r3, [r7, #0]
 800110a:	881b      	ldrh	r3, [r3, #0]
 800110c:	4618      	mov	r0, r3
 800110e:	f7ff fee9 	bl	8000ee4 <Get_PinPostion>
 8001112:	4603      	mov	r3, r0
 8001114:	fa04 f203 	lsl.w	r2, r4, r3
 8001118:	68bb      	ldr	r3, [r7, #8]
 800111a:	681b      	ldr	r3, [r3, #0]
 800111c:	431a      	orrs	r2, r3
 800111e:	68bb      	ldr	r3, [r7, #8]
 8001120:	601a      	str	r2, [r3, #0]
}
 8001122:	bf00      	nop
 8001124:	3714      	adds	r7, #20
 8001126:	46bd      	mov	sp, r7
 8001128:	bd90      	pop	{r4, r7, pc}

0800112a <simple_delay>:
#include "Stm32_F103C6_I2C_driver.h"
#include "I2C_Slave_EEPROM.h"


void simple_delay(volatile uint32_t count)
{
 800112a:	b480      	push	{r7}
 800112c:	b083      	sub	sp, #12
 800112e:	af00      	add	r7, sp, #0
 8001130:	6078      	str	r0, [r7, #4]
    while(count--);
 8001132:	bf00      	nop
 8001134:	687b      	ldr	r3, [r7, #4]
 8001136:	1e5a      	subs	r2, r3, #1
 8001138:	607a      	str	r2, [r7, #4]
 800113a:	2b00      	cmp	r3, #0
 800113c:	d1fa      	bne.n	8001134 <simple_delay+0xa>
}
 800113e:	bf00      	nop
 8001140:	bf00      	nop
 8001142:	370c      	adds	r7, #12
 8001144:	46bd      	mov	sp, r7
 8001146:	bc80      	pop	{r7}
 8001148:	4770      	bx	lr
	...

0800114c <main>:

int main(void)
{
 800114c:	b580      	push	{r7, lr}
 800114e:	b084      	sub	sp, #16
 8001150:	af00      	add	r7, sp, #0
	//enable Clock
	RCC_GPIOA_CLK_EN();
 8001152:	4b26      	ldr	r3, [pc, #152]	@ (80011ec <main+0xa0>)
 8001154:	699b      	ldr	r3, [r3, #24]
 8001156:	4a25      	ldr	r2, [pc, #148]	@ (80011ec <main+0xa0>)
 8001158:	f043 0304 	orr.w	r3, r3, #4
 800115c:	6193      	str	r3, [r2, #24]
	RCC_GPIOB_CLK_EN();
 800115e:	4b23      	ldr	r3, [pc, #140]	@ (80011ec <main+0xa0>)
 8001160:	699b      	ldr	r3, [r3, #24]
 8001162:	4a22      	ldr	r2, [pc, #136]	@ (80011ec <main+0xa0>)
 8001164:	f043 0308 	orr.w	r3, r3, #8
 8001168:	6193      	str	r3, [r2, #24]
	RCC_GPIOC_CLK_EN();
 800116a:	4b20      	ldr	r3, [pc, #128]	@ (80011ec <main+0xa0>)
 800116c:	699b      	ldr	r3, [r3, #24]
 800116e:	4a1f      	ldr	r2, [pc, #124]	@ (80011ec <main+0xa0>)
 8001170:	f043 0310 	orr.w	r3, r3, #16
 8001174:	6193      	str	r3, [r2, #24]

	//test case1
	unsigned char ch1[] = {0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7};
 8001176:	4a1e      	ldr	r2, [pc, #120]	@ (80011f0 <main+0xa4>)
 8001178:	f107 0308 	add.w	r3, r7, #8
 800117c:	e892 0003 	ldmia.w	r2, {r0, r1}
 8001180:	6018      	str	r0, [r3, #0]
 8001182:	3304      	adds	r3, #4
 8001184:	8019      	strh	r1, [r3, #0]
 8001186:	3302      	adds	r3, #2
 8001188:	0c0a      	lsrs	r2, r1, #16
 800118a:	701a      	strb	r2, [r3, #0]
	unsigned char ch2[7] = {0};
 800118c:	463b      	mov	r3, r7
 800118e:	2200      	movs	r2, #0
 8001190:	601a      	str	r2, [r3, #0]
 8001192:	f8c3 2003 	str.w	r2, [r3, #3]

	eeprom_init();
 8001196:	f7fe ffeb 	bl	8000170 <eeprom_init>
	eeprom_write_Nbytes(0xAF, ch1, 7);
 800119a:	f107 0308 	add.w	r3, r7, #8
 800119e:	2207      	movs	r2, #7
 80011a0:	4619      	mov	r1, r3
 80011a2:	20af      	movs	r0, #175	@ 0xaf
 80011a4:	f7ff f804 	bl	80001b0 <eeprom_write_Nbytes>
	eeprom_read_byte(0xAF, ch2, 7);
 80011a8:	463b      	mov	r3, r7
 80011aa:	2207      	movs	r2, #7
 80011ac:	4619      	mov	r1, r3
 80011ae:	20af      	movs	r0, #175	@ 0xaf
 80011b0:	f7ff f868 	bl	8000284 <eeprom_read_byte>

    simple_delay(100000);
 80011b4:	480f      	ldr	r0, [pc, #60]	@ (80011f4 <main+0xa8>)
 80011b6:	f7ff ffb8 	bl	800112a <simple_delay>

	//test case2
	ch1[0] = 0xA;
 80011ba:	230a      	movs	r3, #10
 80011bc:	723b      	strb	r3, [r7, #8]
	ch1[1] = 0xB;
 80011be:	230b      	movs	r3, #11
 80011c0:	727b      	strb	r3, [r7, #9]
	ch1[2] = 0xC;
 80011c2:	230c      	movs	r3, #12
 80011c4:	72bb      	strb	r3, [r7, #10]
	ch1[3] = 0xD;
 80011c6:	230d      	movs	r3, #13
 80011c8:	72fb      	strb	r3, [r7, #11]
	eeprom_write_Nbytes(0xFFF, ch1, 4);
 80011ca:	f107 0308 	add.w	r3, r7, #8
 80011ce:	2204      	movs	r2, #4
 80011d0:	4619      	mov	r1, r3
 80011d2:	f640 70ff 	movw	r0, #4095	@ 0xfff
 80011d6:	f7fe ffeb 	bl	80001b0 <eeprom_write_Nbytes>
	eeprom_read_byte(0xFFF, ch2, 4);
 80011da:	463b      	mov	r3, r7
 80011dc:	2204      	movs	r2, #4
 80011de:	4619      	mov	r1, r3
 80011e0:	f640 70ff 	movw	r0, #4095	@ 0xfff
 80011e4:	f7ff f84e 	bl	8000284 <eeprom_read_byte>



	//loop forever
    while(1)
 80011e8:	bf00      	nop
 80011ea:	e7fd      	b.n	80011e8 <main+0x9c>
 80011ec:	40021000 	.word	0x40021000
 80011f0:	080012ac 	.word	0x080012ac
 80011f4:	000186a0 	.word	0x000186a0

080011f8 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 80011f8:	480d      	ldr	r0, [pc, #52]	@ (8001230 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 80011fa:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 80011fc:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8001200:	480c      	ldr	r0, [pc, #48]	@ (8001234 <LoopForever+0x6>)
  ldr r1, =_edata
 8001202:	490d      	ldr	r1, [pc, #52]	@ (8001238 <LoopForever+0xa>)
  ldr r2, =_sidata
 8001204:	4a0d      	ldr	r2, [pc, #52]	@ (800123c <LoopForever+0xe>)
  movs r3, #0
 8001206:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001208:	e002      	b.n	8001210 <LoopCopyDataInit>

0800120a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800120a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800120c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800120e:	3304      	adds	r3, #4

08001210 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001210:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001212:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001214:	d3f9      	bcc.n	800120a <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001216:	4a0a      	ldr	r2, [pc, #40]	@ (8001240 <LoopForever+0x12>)
  ldr r4, =_ebss
 8001218:	4c0a      	ldr	r4, [pc, #40]	@ (8001244 <LoopForever+0x16>)
  movs r3, #0
 800121a:	2300      	movs	r3, #0
  b LoopFillZerobss
 800121c:	e001      	b.n	8001222 <LoopFillZerobss>

0800121e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800121e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001220:	3204      	adds	r2, #4

08001222 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001222:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001224:	d3fb      	bcc.n	800121e <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8001226:	f000 f811 	bl	800124c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800122a:	f7ff ff8f 	bl	800114c <main>

0800122e <LoopForever>:

LoopForever:
  b LoopForever
 800122e:	e7fe      	b.n	800122e <LoopForever>
  ldr   r0, =_estack
 8001230:	20002800 	.word	0x20002800
  ldr r0, =_sdata
 8001234:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001238:	20000000 	.word	0x20000000
  ldr r2, =_sidata
 800123c:	080012d4 	.word	0x080012d4
  ldr r2, =_sbss
 8001240:	20000000 	.word	0x20000000
  ldr r4, =_ebss
 8001244:	200000b4 	.word	0x200000b4

08001248 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8001248:	e7fe      	b.n	8001248 <ADC1_2_IRQHandler>
	...

0800124c <__libc_init_array>:
 800124c:	b570      	push	{r4, r5, r6, lr}
 800124e:	2600      	movs	r6, #0
 8001250:	4d0c      	ldr	r5, [pc, #48]	@ (8001284 <__libc_init_array+0x38>)
 8001252:	4c0d      	ldr	r4, [pc, #52]	@ (8001288 <__libc_init_array+0x3c>)
 8001254:	1b64      	subs	r4, r4, r5
 8001256:	10a4      	asrs	r4, r4, #2
 8001258:	42a6      	cmp	r6, r4
 800125a:	d109      	bne.n	8001270 <__libc_init_array+0x24>
 800125c:	f000 f81a 	bl	8001294 <_init>
 8001260:	2600      	movs	r6, #0
 8001262:	4d0a      	ldr	r5, [pc, #40]	@ (800128c <__libc_init_array+0x40>)
 8001264:	4c0a      	ldr	r4, [pc, #40]	@ (8001290 <__libc_init_array+0x44>)
 8001266:	1b64      	subs	r4, r4, r5
 8001268:	10a4      	asrs	r4, r4, #2
 800126a:	42a6      	cmp	r6, r4
 800126c:	d105      	bne.n	800127a <__libc_init_array+0x2e>
 800126e:	bd70      	pop	{r4, r5, r6, pc}
 8001270:	f855 3b04 	ldr.w	r3, [r5], #4
 8001274:	4798      	blx	r3
 8001276:	3601      	adds	r6, #1
 8001278:	e7ee      	b.n	8001258 <__libc_init_array+0xc>
 800127a:	f855 3b04 	ldr.w	r3, [r5], #4
 800127e:	4798      	blx	r3
 8001280:	3601      	adds	r6, #1
 8001282:	e7f2      	b.n	800126a <__libc_init_array+0x1e>
 8001284:	080012cc 	.word	0x080012cc
 8001288:	080012cc 	.word	0x080012cc
 800128c:	080012cc 	.word	0x080012cc
 8001290:	080012d0 	.word	0x080012d0

08001294 <_init>:
 8001294:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001296:	bf00      	nop
 8001298:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800129a:	bc08      	pop	{r3}
 800129c:	469e      	mov	lr, r3
 800129e:	4770      	bx	lr

080012a0 <_fini>:
 80012a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80012a2:	bf00      	nop
 80012a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80012a6:	bc08      	pop	{r3}
 80012a8:	469e      	mov	lr, r3
 80012aa:	4770      	bx	lr
